,name,description,b_name,url,issue-key,finding-key,severity,state,cwe,path,status,checker,type,Evidence,Vulnerability desc,Support description,app_name
0,Logically dead code,Code can never be reached because of a logical contradiction.The indicated dead code may have performed some action; that action will never occur.,master,http://ivanti.polaris.synopsys.com/projects/e95bcef8-1a63-4b5b-a2e8-e2b0cee54d77/branches/15de2c52-d415-42e9-8b17-59a530bf8575/revisions/4d324b91-7336-4b9f-b4d6-c29a48ceb332/issues/0024cfd4147815af2fc951d2823a234c433beda98473d6302e2325b2cf892508,0024cfd4147815af2fc951d2823a234c433beda98473d6302e2325b2cf892508,3c9ddd265ed7c8410ad5a7ed09d0d21d,7.5,opened,"CWE-1164,CWE-561",DynamicWebServiceTest/Form1.cs,,DEADCODE,deadcode:logical_contradiction|c#,"63 	                if (credential != null)
64 	                    credCache.Add(new Uri(wsdlAddress), authType, credential);
65 	
66 	                try
67 	                {
68 	                    _webServiceProxyGenerator = ProxyGeneratorFactory.GetProxyGeneratorType(wsdlAddress, credential, BindingType.Default);
","Execution cannot reach the expression ""credCache.Add(new System.Uri(wsdlAddress), authType, credential)"" inside this statement: ""credCache.Add(new System.Ur..."".",,IntegrationServer
1,Non-constant SQL,"An SQL statement is constructed by concatenating a non-constant string..Malicious or rogue values may alter the intent of the SQL query or command and cause incorrect behavior, leaked sensitive information, or a loss of data.",master,http://ivanti.polaris.synopsys.com/projects/e95bcef8-1a63-4b5b-a2e8-e2b0cee54d77/branches/15de2c52-d415-42e9-8b17-59a530bf8575/revisions/13a7ac9a-aa5f-4981-b23c-fd28ddfad0e5/issues/02f4592b89320b3073cc54244361d42a3b0c9be2689ebfcb0ff71b70c9d9d9d3,02f4592b89320b3073cc54244361d42a3b0c9be2689ebfcb0ff71b70c9d9d9d3,9ce45fd19d18746a5757a84ef880b4cb,2.0,opened,"CWE-141,CWE-142,CWE-143,CWE-146,CWE-149,CWE-150,CWE-157,CWE-566,CWE-89",IntegrationDataAccess/IntegrationDataAccess.cs,,SQL_NOT_CONSTANT,sql_injection:audit_non_constant_concat|c#,"1541 	                sql.Append("") "");
1542 	                sql.Append(""VALUES (@RecId, @CreatedBy, @CreatedDateTime, @LastModBy, @LastModDateTime, @ReadOnly, "")
1543 	                    .Append("" @CallerMode, @IsSyncMode, "")
1544 	                    .Append(""@Owner,  @Status, @StartTime, @Message"");
1545 	                sql.Append("")"");
1546 	                SqlCommand cmd = new SqlCommand(sql.ToString(), conn);
1547 	                DateTime now = DateTime.UtcNow;
","Calling ""SqlCommand"". Passing the tainted value ""sql.ToString()"" to the SQL API may allow an attacker to inject SQL.","Calling ""ToString"". This call assigns ""sql"" to ""<return value>"". Now ""<return value>"" is tainted.
Calling ""ToString"". This call returns a reference to ""<return value>"".
Use one of the following methods:
* Use a query-preparation API to safely construct the SQL query containing user-supplied values.
* Only concatenate a user-supplied value into a query if it has been checked against a whitelist of safe string values, or if it must be a Boolean or numeric type.

",IntegrationServer
2,Non-constant SQL,"An SQL statement is constructed by concatenating a non-constant string..Malicious or rogue values may alter the intent of the SQL query or command and cause incorrect behavior, leaked sensitive information, or a loss of data.",master,http://ivanti.polaris.synopsys.com/projects/e95bcef8-1a63-4b5b-a2e8-e2b0cee54d77/branches/15de2c52-d415-42e9-8b17-59a530bf8575/revisions/8745edb0-f94e-4ee5-b61f-5a6786c15d4d/issues/1076719e8506e3e011c682b1ad4234df21d92807fcc37f69175a4b8d1fad32a4,1076719e8506e3e011c682b1ad4234df21d92807fcc37f69175a4b8d1fad32a4,51ff360ad905ff9ddbc01533343d26cc,2.0,opened,"CWE-141,CWE-142,CWE-143,CWE-146,CWE-149,CWE-150,CWE-157,CWE-566,CWE-89",IntegrationDataAccess/IntegrationDataAccess.cs,,SQL_NOT_CONSTANT,sql_injection:audit_non_constant_concat|c#,"647 	            var columnNames = new HashSet<string>();
648 	            StringBuilder sql = new StringBuilder();
649 	            sql.Append(""SELECT [COLUMN_NAME] FROM information_schema.columns "")
650 	                .Append(""WHERE [TABLE_NAME] = @TableName"");
652 	            SqlCommand cmd = new SqlCommand(sql.ToString(), conn);
653 	            cmd.Parameters.AddWithValue(""@TableName"", tableName);
","Calling ""SqlCommand"". Passing the tainted value ""sql.ToString()"" to the SQL API may allow an attacker to inject SQL.","Calling ""ToString"". This call assigns ""sql"" to ""<return value>"". Now ""<return value>"" is tainted.
Calling ""ToString"". This call returns a reference to ""<return value>"".
Use one of the following methods:
* Use a query-preparation API to safely construct the SQL query containing user-supplied values.
* Only concatenate a user-supplied value into a query if it has been checked against a whitelist of safe string values, or if it must be a Boolean or numeric type.

",IntegrationServer
3,Log injection,User-controllable data is stored in logs..An attacker may be able to forge log messages to confuse automated log parsing tools or humans trying to diagnose an attack or other problem.,master,http://ivanti.polaris.synopsys.com/projects/e95bcef8-1a63-4b5b-a2e8-e2b0cee54d77/branches/15de2c52-d415-42e9-8b17-59a530bf8575/revisions/13a7ac9a-aa5f-4981-b23c-fd28ddfad0e5/issues/1188216640d43571f950c087f13081ba7a9ccb2c422471b4d244af16415c3aa9,1188216640d43571f950c087f13081ba7a9ccb2c422471b4d244af16415c3aa9,5ef36443e841cdde5fb4fc9f62d7f42a,2.0,opened,CWE-117,tools/IntegrationRecordingTool/SoftwareInventoryTool/Program.cs,,LOG_INJECTION,log_injection:audit|c#,"67 	                {
68 	                    string blobContent = File.ReadAllText(file.FullName);
69 	
70 	                    dynamic deviceData = JsonConvert.DeserializeObject(blobContent);
72 	                    Console.WriteLine($""Reading DiscoveryId {deviceData.DiscoveryId.Value} . . ."");
","Calling ""WriteLine"". This call uses ""System.String.Format(""Reading DiscoveryId {0} . . ."", deviceData.DiscoveryId.Value)"" for sensitive computation.","""deviceData.DiscoveryId.Value"" invokes an unknown or unresolved function which might return untrusted data.
Calling ""Format"". This call returns a reference to ""<return value>"".
Log injection vulnerabilities can be addressed by validating that the user-controllable input conforms to expectations.
",IntegrationServer
4,Non-constant SQL,"An SQL statement is constructed by concatenating a non-constant string..Malicious or rogue values may alter the intent of the SQL query or command and cause incorrect behavior, leaked sensitive information, or a loss of data.",master,http://ivanti.polaris.synopsys.com/projects/e95bcef8-1a63-4b5b-a2e8-e2b0cee54d77/branches/15de2c52-d415-42e9-8b17-59a530bf8575/revisions/13a7ac9a-aa5f-4981-b23c-fd28ddfad0e5/issues/12dca51b61d2de0ca252d2aba24068447642f301bee7d814d1feedea2107bba3,12dca51b61d2de0ca252d2aba24068447642f301bee7d814d1feedea2107bba3,48f02dbd75688ee84ab8b2cd7552f503,2.0,opened,"CWE-141,CWE-142,CWE-143,CWE-146,CWE-149,CWE-150,CWE-157,CWE-566,CWE-89",IntegrationDataAccess/IntegrationDataAccess.cs,,SQL_NOT_CONSTANT,sql_injection:audit_non_constant_concat|c#,"1494 	                    .Append(""@Owner, @RunAs, @Status, @StartTime, @Output, @Message"");
1495 	                if (scriptDef.IsSyncMode)
1496 	                    sql.Append("", @EndTime)"");
1497 	                else
1498 	                    sql.Append("")"");
1499 	                SqlCommand cmd = new SqlCommand(sql.ToString(), conn);
1500 	                DateTime now = DateTime.UtcNow;
","Calling ""SqlCommand"". Passing the tainted value ""sql.ToString()"" to the SQL API may allow an attacker to inject SQL.","Calling ""ToString"". This call assigns ""sql"" to ""<return value>"". Now ""<return value>"" is tainted.
Calling ""ToString"". This call returns a reference to ""<return value>"".
Use one of the following methods:
* Use a query-preparation API to safely construct the SQL query containing user-supplied values.
* Only concatenate a user-supplied value into a query if it has been checked against a whitelist of safe string values, or if it must be a Boolean or numeric type.

",IntegrationServer
5,Non-constant SQL,"An SQL statement is constructed by concatenating a non-constant string..Malicious or rogue values may alter the intent of the SQL query or command and cause incorrect behavior, leaked sensitive information, or a loss of data.",master,http://ivanti.polaris.synopsys.com/projects/e95bcef8-1a63-4b5b-a2e8-e2b0cee54d77/branches/15de2c52-d415-42e9-8b17-59a530bf8575/revisions/13a7ac9a-aa5f-4981-b23c-fd28ddfad0e5/issues/1f90dce6ddf5e004450b3714c3286448c5a3adaa495d1fc52d514116c03a2185,1f90dce6ddf5e004450b3714c3286448c5a3adaa495d1fc52d514116c03a2185,e78ee3595dc760823730c8c619e12e8c,2.0,opened,"CWE-141,CWE-142,CWE-143,CWE-146,CWE-149,CWE-150,CWE-157,CWE-566,CWE-89",IntegrationDataAccess/IntegrationDataAccess.cs,,SQL_NOT_CONSTANT,sql_injection:audit_non_constant_concat|c#,"147 	            StringBuilder selectSQL = new StringBuilder();
148 	            selectSQL.Append(""SELECT i.Name, c.DB FROM Frs_def_integration i left join Frs_def_integration_connection c on i.ConnectionLink_RecID = c.RecId WHERE i.RecId = @Id"");
149 	
150 	            using (SqlConnection conn = (SqlConnection)this.GetConnection(DBAuth.ConnStringWithProvider(), DBAuth.TenantId))
151 	            {
152 	                SqlCommand cmd = new SqlCommand(selectSQL.ToString(), conn);
153 	                cmd.Parameters.AddWithValue(""@Id"", integrationId);
","Calling ""SqlCommand"". Passing the tainted value ""selectSQL.ToString()"" to the SQL API may allow an attacker to inject SQL.","Calling ""ToString"". This call assigns ""selectSQL"" to ""<return value>"". Now ""<return value>"" is tainted.
Calling ""ToString"". This call returns a reference to ""<return value>"".
Use one of the following methods:
* Use a query-preparation API to safely construct the SQL query containing user-supplied values.
* Only concatenate a user-supplied value into a query if it has been checked against a whitelist of safe string values, or if it must be a Boolean or numeric type.

",IntegrationServer
6,Non-constant SQL,"An SQL statement is constructed by concatenating a non-constant string..Malicious or rogue values may alter the intent of the SQL query or command and cause incorrect behavior, leaked sensitive information, or a loss of data.",master,http://ivanti.polaris.synopsys.com/projects/e95bcef8-1a63-4b5b-a2e8-e2b0cee54d77/branches/15de2c52-d415-42e9-8b17-59a530bf8575/revisions/13a7ac9a-aa5f-4981-b23c-fd28ddfad0e5/issues/231d3e18ba1e95893e1fc5611b7add525e875a9bc32981a2b2889523130c71f5,231d3e18ba1e95893e1fc5611b7add525e875a9bc32981a2b2889523130c71f5,b4bf56a5b6d5572cef45103295f427da,2.0,opened,"CWE-141,CWE-142,CWE-143,CWE-146,CWE-149,CWE-150,CWE-157,CWE-566,CWE-89",IntegrationDataAccess/IntegrationDataAccess.cs,,SQL_NOT_CONSTANT,sql_injection:audit_non_constant_concat|c#,"1356 	            {
1357 	                StringBuilder sql = new StringBuilder();
1358 	                sql.Append(""UPDATE i SET i.NextSync = (SELECT MIN(ExpirationDatetime) from Frs_ops_workflow_timer where userdata = 'Frs_def_integration' "")
1359 	                   .Append(""and userdata2 = i.RecId and EscServiceId = 5)"")
1360 	                   .Append(""FROM Frs_def_integration i"");
1361 	                SqlCommand updateCmd = new SqlCommand(sql.ToString(), conn);
","Calling ""SqlCommand"". Passing the tainted value ""sql.ToString()"" to the SQL API may allow an attacker to inject SQL.","Calling ""ToString"". This call assigns ""sql"" to ""<return value>"". Now ""<return value>"" is tainted.
Calling ""ToString"". This call returns a reference to ""<return value>"".
Use one of the following methods:
* Use a query-preparation API to safely construct the SQL query containing user-supplied values.
* Only concatenate a user-supplied value into a query if it has been checked against a whitelist of safe string values, or if it must be a Boolean or numeric type.

",IntegrationServer
7,Non-constant SQL,"An SQL statement is constructed by concatenating a non-constant string..Malicious or rogue values may alter the intent of the SQL query or command and cause incorrect behavior, leaked sensitive information, or a loss of data.",master,http://ivanti.polaris.synopsys.com/projects/e95bcef8-1a63-4b5b-a2e8-e2b0cee54d77/branches/15de2c52-d415-42e9-8b17-59a530bf8575/revisions/13a7ac9a-aa5f-4981-b23c-fd28ddfad0e5/issues/2e2eedcb9e5575b9a52ceec1d049507c025aa8689c73db34fea2c4191a0e7754,2e2eedcb9e5575b9a52ceec1d049507c025aa8689c73db34fea2c4191a0e7754,31b90120a98688976ef325a4b99bc428,2.0,opened,"CWE-141,CWE-142,CWE-143,CWE-146,CWE-149,CWE-150,CWE-157,CWE-566,CWE-89",IntegrationDataAccess/IntegrationDataAccess.cs,,SQL_NOT_CONSTANT,sql_injection:audit_non_constant_concat|c#,"1208 	                   .Append(""([RecId], [ExpirationDatetime], [EscServiceId], [UserData], [UserData2], [WorkflowInstanceId], [WorkflowBlockId]) "")
1209 	                   .Append(""VALUES (@RecId, DATEADD(SECOND, @SetOffInSeconds, GETUTCDATE()), @EscServiceId, 'Frs_def_integration', @integrationObjectRecId, 'ScheduleEntry', @scheduleRecId)"");
1210 	
1211 	                using (SqlTransaction trans = conn.BeginTransaction())
1212 	                {
1213 	                    SqlCommand cmd = new SqlCommand(sql.ToString(), conn);
1214 	                    cmd.Transaction = trans;
","Calling ""SqlCommand"". Passing the tainted value ""sql.ToString()"" to the SQL API may allow an attacker to inject SQL.","Calling ""ToString"". This call assigns ""sql"" to ""<return value>"". Now ""<return value>"" is tainted.
Calling ""ToString"". This call returns a reference to ""<return value>"".
Use one of the following methods:
* Use a query-preparation API to safely construct the SQL query containing user-supplied values.
* Only concatenate a user-supplied value into a query if it has been checked against a whitelist of safe string values, or if it must be a Boolean or numeric type.

",IntegrationServer
8,Explicit null dereferenced,Dereference of an explicit null value.A null pointer exception will occur.,master,http://ivanti.polaris.synopsys.com/projects/e95bcef8-1a63-4b5b-a2e8-e2b0cee54d77/branches/15de2c52-d415-42e9-8b17-59a530bf8575/revisions/4d324b91-7336-4b9f-b4d6-c29a48ceb332/issues/30528ac31f2ba1ec26b65b960ddbb9f38f97bafb8bc5bd6a3c21e72eb43df75c,30528ac31f2ba1ec26b65b960ddbb9f38f97bafb8bc5bd6a3c21e72eb43df75c,dedbd023a64fa710f7ad4ce8223be9d8,7.5,opened,CWE-476,XMLGenerator/GenerateXML.cs,,FORWARD_NULL,null_pointer_dereference_exception:constant_null|c#,"162 	            switch (name)
163 	            {
164 	                case ""Incident"":
165 	                    writer.WriteStartElement(""UniqueKey"");
166 	                    writer.WriteStartElement(""Field"");
167 	                    writer.WriteAttributeString(""Name"", null, ""IncidentNumber"");
168 	                    writer.WriteEndElement();
169 	                    writer.WriteEndElement();
170 	                    break;
171 	                case ""Change"":
","Passing ""null"" to ""WriteAttributeString"", which dereferences it.",,IntegrationServer
9,Non-constant SQL,"An SQL statement is constructed by concatenating a non-constant string..Malicious or rogue values may alter the intent of the SQL query or command and cause incorrect behavior, leaked sensitive information, or a loss of data.",master,http://ivanti.polaris.synopsys.com/projects/e95bcef8-1a63-4b5b-a2e8-e2b0cee54d77/branches/15de2c52-d415-42e9-8b17-59a530bf8575/revisions/13a7ac9a-aa5f-4981-b23c-fd28ddfad0e5/issues/380d337d8bf50a21df356643862ca9406d8bbbad1ed63192376331be54e3a97a,380d337d8bf50a21df356643862ca9406d8bbbad1ed63192376331be54e3a97a,97a7012c8275edfb46c541ca0a541fb5,2.0,opened,"CWE-141,CWE-142,CWE-143,CWE-146,CWE-149,CWE-150,CWE-157,CWE-566,CWE-89",IntegrationDataAccess/IntegrationDataAccess.cs,,SQL_NOT_CONSTANT,sql_injection:audit_non_constant_concat|c#,"1243 	                   .Append(""WHERE [EscServiceId] = @EscServiceId "")
1244 	                   .Append(""AND [UserData] = 'Frs_def_integration' "")
1245 	                   .Append(""AND [UserData2] = @integrationObjectRecId "")
1246 	                   .Append(""AND [WorkflowInstanceId] = 'ScheduleEntry' "")
1247 	                   .Append(""AND [WorkflowBlockId] = @scheduleRecid"");
1248 	                SqlCommand cmd = new SqlCommand(sql.ToString(), conn);
","Calling ""SqlCommand"". Passing the tainted value ""sql.ToString()"" to the SQL API may allow an attacker to inject SQL.","Calling ""ToString"". This call assigns ""sql"" to ""<return value>"". Now ""<return value>"" is tainted.
Calling ""ToString"". This call returns a reference to ""<return value>"".
Use one of the following methods:
* Use a query-preparation API to safely construct the SQL query containing user-supplied values.
* Only concatenate a user-supplied value into a query if it has been checked against a whitelist of safe string values, or if it must be a Boolean or numeric type.

",IntegrationServer
10,Dereference null return value,"Return value of function which returns null is dereferenced without checking.If the function actually returns a null reference, a null reference exception will occur.",master,http://ivanti.polaris.synopsys.com/projects/e95bcef8-1a63-4b5b-a2e8-e2b0cee54d77/branches/15de2c52-d415-42e9-8b17-59a530bf8575/revisions/4d324b91-7336-4b9f-b4d6-c29a48ceb332/issues/3dc2f750b4601017914a08f6d57f1959e152161a402c3b5ff2a938db0eab7760,3dc2f750b4601017914a08f6d57f1959e152161a402c3b5ff2a938db0eab7760,cc79c170b2cc7dfaaa2c2f1c5e76a6c8,7.5,opened,CWE-476,tools/Message_Generator_Utility/Message_Generator_Utility/Program.cs,,NULL_RETURNS,null_pointer_dereference_exception:return_value|c#,"36 	                    if (deletefromPath)
37 	                    {
38 	                        deletefiles(InvoiceBlobPath);
39 	                        deletefiles(InvoiceMessagePath);
40 	                    }
41 	                    InvoiceGenerator(UnoTenantId, Tenant_id, NoOfMessage, InvoiceMessagePath, InvoiceBlobPath);
42 	                }
","Throws an exception when ""InvoiceBlobPath"", a pointer that might be ""null"", is ""null"" when calling ""deletefiles"".",,IntegrationServer
11,Non-constant SQL,"An SQL statement is constructed by concatenating a non-constant string..Malicious or rogue values may alter the intent of the SQL query or command and cause incorrect behavior, leaked sensitive information, or a loss of data.",master,http://ivanti.polaris.synopsys.com/projects/e95bcef8-1a63-4b5b-a2e8-e2b0cee54d77/branches/15de2c52-d415-42e9-8b17-59a530bf8575/revisions/13a7ac9a-aa5f-4981-b23c-fd28ddfad0e5/issues/4083c72e5b51e30622262d497b056df2ef01c36ef31209636fa7170d1371ab51,4083c72e5b51e30622262d497b056df2ef01c36ef31209636fa7170d1371ab51,16ca475ebf8904d7dd710752b377c06c,2.0,opened,"CWE-141,CWE-142,CWE-143,CWE-146,CWE-149,CWE-150,CWE-157,CWE-566,CWE-89",IntegrationDataAccess/IntegrationDataAccess.cs,,SQL_NOT_CONSTANT,sql_injection:audit_non_constant_concat|c#,"1175 	                builder.Append("" from "");
1176 	                builder.Append("" FRS_TimeZone"");
1177 	                builder.Append("" where IsEnabled = 1"");
1178 	                builder.Append("" order by TimeZoneId"");
1180 	                SqlCommand cmd = new SqlCommand(builder.ToString(), conn);
1181 	                using (SqlDataReader reader = cmd.ExecuteReader())
","Calling ""SqlCommand"". Passing the tainted value ""builder.ToString()"" to the SQL API may allow an attacker to inject SQL.","Calling ""ToString"". This call assigns ""builder"" to ""<return value>"". Now ""<return value>"" is tainted.
Calling ""ToString"". This call returns a reference to ""<return value>"".
Use one of the following methods:
* Use a query-preparation API to safely construct the SQL query containing user-supplied values.
* Only concatenate a user-supplied value into a query if it has been checked against a whitelist of safe string values, or if it must be a Boolean or numeric type.

",IntegrationServer
12,Non-constant SQL,"An SQL statement is constructed by concatenating a non-constant string..Malicious or rogue values may alter the intent of the SQL query or command and cause incorrect behavior, leaked sensitive information, or a loss of data.",master,http://ivanti.polaris.synopsys.com/projects/e95bcef8-1a63-4b5b-a2e8-e2b0cee54d77/branches/15de2c52-d415-42e9-8b17-59a530bf8575/revisions/13a7ac9a-aa5f-4981-b23c-fd28ddfad0e5/issues/43463ef069e8e1033e3c25cabfcefaf3581e4f521e0fe3db67b2d440080c60fc,43463ef069e8e1033e3c25cabfcefaf3581e4f521e0fe3db67b2d440080c60fc,ad65b6c75fd8394ab0f855722cfdf61b,2.0,opened,"CWE-141,CWE-142,CWE-143,CWE-146,CWE-149,CWE-150,CWE-157,CWE-566,CWE-89",IntegrationDataAccess/IntegrationDataAccess.cs,,SQL_NOT_CONSTANT,sql_injection:audit_non_constant_concat|c#,"1775 	                StringBuilder selectSQL = new StringBuilder();
1776 	                selectSQL.Append(""SELECT ClientID, ClientSecret, RegistrationAccessToken, RegistrationClientUri FROM UnoClientRegistrationDetails"");
1777 	
1778 	                using (SqlConnection conn = (SqlConnection)this.GetConnection(DBAuth.ConnStringWithProvider(), DBAuth.TenantId))
1779 	                {
1780 	                    SqlCommand cmd = new SqlCommand(selectSQL.ToString(), conn);
","Calling ""SqlCommand"". Passing the tainted value ""selectSQL.ToString()"" to the SQL API may allow an attacker to inject SQL.","Calling ""ToString"". This call assigns ""selectSQL"" to ""<return value>"". Now ""<return value>"" is tainted.
Calling ""ToString"". This call returns a reference to ""<return value>"".
Use one of the following methods:
* Use a query-preparation API to safely construct the SQL query containing user-supplied values.
* Only concatenate a user-supplied value into a query if it has been checked against a whitelist of safe string values, or if it must be a Boolean or numeric type.

",IntegrationServer
13,Non-constant SQL,"An SQL statement is constructed by concatenating a non-constant string..Malicious or rogue values may alter the intent of the SQL query or command and cause incorrect behavior, leaked sensitive information, or a loss of data.",master,http://ivanti.polaris.synopsys.com/projects/e95bcef8-1a63-4b5b-a2e8-e2b0cee54d77/branches/15de2c52-d415-42e9-8b17-59a530bf8575/revisions/13a7ac9a-aa5f-4981-b23c-fd28ddfad0e5/issues/44d6466af08194d171d236cf262bb15d1e8390d097968f55927b5c18dff749c4,44d6466af08194d171d236cf262bb15d1e8390d097968f55927b5c18dff749c4,6141f64ac731eb5907c76904491ce918,2.0,opened,"CWE-141,CWE-142,CWE-143,CWE-146,CWE-149,CWE-150,CWE-157,CWE-566,CWE-89",IntegrationDataAccess/IntegrationDataAccess.cs,,SQL_NOT_CONSTANT,sql_injection:audit_non_constant_concat|c#,"1039 	                    .Append(""([RecId], [CreatedBy], [CreatedDateTime], [LastModBy], [LastModDateTime], [ReadOnly], "")
1040 	                    .Append(""[TotalProcessed], [FailedCount], [Message], [ParentLink_RecID], [ParentLink_Category], [EndTime], [StartTime], [LogType]) "")
1041 	                    .Append(""VALUES (@RecId, @CreatedBy, @CreatedDateTime, @LastModBy, @LastModDateTime, @ReadOnly, "")
1042 	                    .Append(""@TotalProcessed, @FailedCount, @Message, @ParentLink_RecID, @ParentLink_Category, @EndTime, "")
1043 	                    .Append(""(SELECT StartTime FROM [Frs_ops_integration_queue] WHERE [RecId] = @EventRecId), @LogType)"");
1044 	                SqlCommand cmd = new SqlCommand(sql.ToString(), conn);
1045 	                DateTime now = DateTime.UtcNow;
","Calling ""SqlCommand"". Passing the tainted value ""sql.ToString()"" to the SQL API may allow an attacker to inject SQL.","Calling ""ToString"". This call assigns ""sql"" to ""<return value>"". Now ""<return value>"" is tainted.
Calling ""ToString"". This call returns a reference to ""<return value>"".
Use one of the following methods:
* Use a query-preparation API to safely construct the SQL query containing user-supplied values.
* Only concatenate a user-supplied value into a query if it has been checked against a whitelist of safe string values, or if it must be a Boolean or numeric type.

",IntegrationServer
14,Non-constant SQL,"An SQL statement is constructed by concatenating a non-constant string..Malicious or rogue values may alter the intent of the SQL query or command and cause incorrect behavior, leaked sensitive information, or a loss of data.",master,http://ivanti.polaris.synopsys.com/projects/e95bcef8-1a63-4b5b-a2e8-e2b0cee54d77/branches/15de2c52-d415-42e9-8b17-59a530bf8575/revisions/13a7ac9a-aa5f-4981-b23c-fd28ddfad0e5/issues/44f056135a561b872b446559ef97dc69a71fbba7d75b010d4a1ed32cdeee692e,44f056135a561b872b446559ef97dc69a71fbba7d75b010d4a1ed32cdeee692e,972db0abca3bd450fac7aa2c097c5bde,2.0,opened,"CWE-141,CWE-142,CWE-143,CWE-146,CWE-149,CWE-150,CWE-157,CWE-566,CWE-89",IntegrationDataAccess/IntegrationDataAccess.cs,,SQL_NOT_CONSTANT,sql_injection:audit_non_constant_concat|c#,"1453 	            StringBuilder sql = new StringBuilder(""UPDATE Frs_data_integration_log SET LogType = @Verified "")
1454 	                .Append(""FROM Frs_data_integration_log l JOIN ci ON l.targetID = ci.clientid "")
1455 	                .Append(""WHERE l.Logtype = @Queued AND ( ci.LastModDateTime > l.StartTime OR ci.Status = @Retired OR ci.Status = @Disposed)"");
1456 	            using (SqlConnection conn = (SqlConnection)this.GetConnection(DBAuth.ConnStringWithProvider(), DBAuth.TenantId))
1457 	            {
1458 	                SqlCommand cmd = new SqlCommand(sql.ToString(), conn);
1459 	                cmd.Parameters.AddWithValue(""@Verified"", LogType.Verified.ToString());
","Calling ""SqlCommand"". Passing the tainted value ""sql.ToString()"" to the SQL API may allow an attacker to inject SQL.","Calling ""ToString"". This call assigns ""sql"" to ""<return value>"". Now ""<return value>"" is tainted.
Calling ""ToString"". This call returns a reference to ""<return value>"".
Use one of the following methods:
* Use a query-preparation API to safely construct the SQL query containing user-supplied values.
* Only concatenate a user-supplied value into a query if it has been checked against a whitelist of safe string values, or if it must be a Boolean or numeric type.

",IntegrationServer
15,Non-constant SQL,"An SQL statement is constructed by concatenating a non-constant string..Malicious or rogue values may alter the intent of the SQL query or command and cause incorrect behavior, leaked sensitive information, or a loss of data.",master,http://ivanti.polaris.synopsys.com/projects/e95bcef8-1a63-4b5b-a2e8-e2b0cee54d77/branches/15de2c52-d415-42e9-8b17-59a530bf8575/revisions/13a7ac9a-aa5f-4981-b23c-fd28ddfad0e5/issues/4a536bf8a774e5e268591fd74062eee253eaed59341b009c8db440957f73959f,4a536bf8a774e5e268591fd74062eee253eaed59341b009c8db440957f73959f,b8ce35a2ee6737675794ada301aa5ca7,2.0,opened,"CWE-141,CWE-142,CWE-143,CWE-146,CWE-149,CWE-150,CWE-157,CWE-566,CWE-89",IntegrationDataAccess/IntegrationDataAccess.cs,,SQL_NOT_CONSTANT,sql_injection:audit_non_constant_concat|c#,"754 	                        sql.Append("", SourceName = @BatchSource"");
755 	                        cmd.Parameters.AddWithValue(""@BatchSource"", batchinfo.BatchSource);
756 	                    }
757 	
758 	                    sql.Append("" WHERE QueueLink_RecID = @RecId"");
759 	                    cmd.CommandText = sql.ToString();
760 	                }
","Calling ""CommandText.set"". Passing the tainted value ""sql.ToString()"" to the SQL API may allow an attacker to inject SQL. (The virtual call resolves to ""System.Data.SqlClient.SqlCommand.CommandText.set(System.String)"".)","Calling ""ToString"". This call assigns ""sql"" to ""<return value>"". Now ""<return value>"" is tainted.
Calling ""ToString"". This call returns a reference to ""<return value>"".
Use one of the following methods:
* Use a query-preparation API to safely construct the SQL query containing user-supplied values.
* Only concatenate a user-supplied value into a query if it has been checked against a whitelist of safe string values, or if it must be a Boolean or numeric type.

",IntegrationServer
16,Non-constant SQL,"An SQL statement is constructed by concatenating a non-constant string..Malicious or rogue values may alter the intent of the SQL query or command and cause incorrect behavior, leaked sensitive information, or a loss of data.",master,http://ivanti.polaris.synopsys.com/projects/e95bcef8-1a63-4b5b-a2e8-e2b0cee54d77/branches/15de2c52-d415-42e9-8b17-59a530bf8575/revisions/13a7ac9a-aa5f-4981-b23c-fd28ddfad0e5/issues/4bc0234066994a9c10660823cfeb9224a24d870a342eebdcec3bb9fd5fc0820a,4bc0234066994a9c10660823cfeb9224a24d870a342eebdcec3bb9fd5fc0820a,6a8ab50658cbccfa69e3f18bfa46a12f,2.0,opened,"CWE-141,CWE-142,CWE-143,CWE-146,CWE-149,CWE-150,CWE-157,CWE-566,CWE-89",IntegrationDataAccess/IntegrationDataAccess.cs,,SQL_NOT_CONSTANT,sql_injection:audit_non_constant_concat|c#,"352 	
353 	                builder.Append(""SELECT * "")
354 	                       .Append(""FROM Frs_ops_integration_queue "")
355 	                       .Append(""WHERE [Status] = @AbortRequested"");
357 	                SqlCommand cmd = new SqlCommand(builder.ToString(), conn);
358 	                cmd.Parameters.AddWithValue(""@AbortRequested"", ""AbortRequested"");
","Calling ""SqlCommand"". Passing the tainted value ""builder.ToString()"" to the SQL API may allow an attacker to inject SQL.","Calling ""ToString"". This call assigns ""builder"" to ""<return value>"". Now ""<return value>"" is tainted.
Calling ""ToString"". This call returns a reference to ""<return value>"".
Use one of the following methods:
* Use a query-preparation API to safely construct the SQL query containing user-supplied values.
* Only concatenate a user-supplied value into a query if it has been checked against a whitelist of safe string values, or if it must be a Boolean or numeric type.

",IntegrationServer
17,Non-constant SQL,"An SQL statement is constructed by concatenating a non-constant string..Malicious or rogue values may alter the intent of the SQL query or command and cause incorrect behavior, leaked sensitive information, or a loss of data.",master,http://ivanti.polaris.synopsys.com/projects/e95bcef8-1a63-4b5b-a2e8-e2b0cee54d77/branches/15de2c52-d415-42e9-8b17-59a530bf8575/revisions/13a7ac9a-aa5f-4981-b23c-fd28ddfad0e5/issues/50dfe52f5b034c4efe476dc66b6d41213a56dd95bf94b1cc2c5011a3bdf6eff0,50dfe52f5b034c4efe476dc66b6d41213a56dd95bf94b1cc2c5011a3bdf6eff0,d007ede1756764ae8adb9c2ddddce605,2.0,opened,"CWE-141,CWE-142,CWE-143,CWE-146,CWE-149,CWE-150,CWE-157,CWE-566,CWE-89",IntegrationDataAccess/IntegrationDataAccess.cs,,SQL_NOT_CONSTANT,sql_injection:audit_non_constant_concat|c#,"1379 	                       .Append(""AND [WorkflowInstanceId] = 'ScheduleEntry' "")
1380 	                       .Append(""AND [ExpirationDatetime] <= GETUTCDATE() "")
1381 	                       .Append(""AND i.[Active] = 1 "")
1382 	                       .Append(""ORDER BY timer_id "");
1384 	                SqlCommand cmd = new SqlCommand(builder.ToString(), conn);
1385 	                cmd.Parameters.AddWithValue(""@EscServiceId"", com.frontrange.saas.Workflow.Common.Enums.EscServiceIdEnum.IntegrationService);
","Calling ""SqlCommand"". Passing the tainted value ""builder.ToString()"" to the SQL API may allow an attacker to inject SQL.","Calling ""ToString"". This call returns a reference to ""<return value>"".
Use one of the following methods:
* Use a query-preparation API to safely construct the SQL query containing user-supplied values.
* Only concatenate a user-supplied value into a query if it has been checked against a whitelist of safe string values, or if it must be a Boolean or numeric type.

Calling ""ToString"". This call assigns ""builder"" to ""<return value>"". Now ""<return value>"" is tainted.
",IntegrationServer
18,Non-constant SQL,"An SQL statement is constructed by concatenating a non-constant string..Malicious or rogue values may alter the intent of the SQL query or command and cause incorrect behavior, leaked sensitive information, or a loss of data.",master,http://ivanti.polaris.synopsys.com/projects/e95bcef8-1a63-4b5b-a2e8-e2b0cee54d77/branches/15de2c52-d415-42e9-8b17-59a530bf8575/revisions/8745edb0-f94e-4ee5-b61f-5a6786c15d4d/issues/5675609735afda24f751c647d30b6f77570e5b4c3d544979cc776607e6edcc05,5675609735afda24f751c647d30b6f77570e5b4c3d544979cc776607e6edcc05,484131dc08b5d263750b17dac786349c,2.0,opened,"CWE-141,CWE-142,CWE-143,CWE-146,CWE-149,CWE-150,CWE-157,CWE-566,CWE-89",IntegrationDataAccess/IntegrationDataAccess.cs,,SQL_NOT_CONSTANT,sql_injection:audit_non_constant_concat|c#,"2054 	                    .Append("" WHERE [HandlerName] is not null"")
2055 	                    .Append("" and [Status] = @oldstatus"");
2056 	
2057 	                using (SqlTransaction trans = conn.BeginTransaction())
2058 	                {
2059 	                    SqlCommand cmd = new SqlCommand(sql.ToString(), conn);
2060 	                    cmd.Transaction = trans;
","Calling ""SqlCommand"". Passing the tainted value ""sql.ToString()"" to the SQL API may allow an attacker to inject SQL.","Calling ""ToString"". This call assigns ""sql"" to ""<return value>"". Now ""<return value>"" is tainted.
Calling ""ToString"". This call returns a reference to ""<return value>"".
Use one of the following methods:
* Use a query-preparation API to safely construct the SQL query containing user-supplied values.
* Only concatenate a user-supplied value into a query if it has been checked against a whitelist of safe string values, or if it must be a Boolean or numeric type.

",IntegrationServer
19,Non-constant SQL,"An SQL statement is constructed by concatenating a non-constant string..Malicious or rogue values may alter the intent of the SQL query or command and cause incorrect behavior, leaked sensitive information, or a loss of data.",master,http://ivanti.polaris.synopsys.com/projects/e95bcef8-1a63-4b5b-a2e8-e2b0cee54d77/branches/15de2c52-d415-42e9-8b17-59a530bf8575/revisions/13a7ac9a-aa5f-4981-b23c-fd28ddfad0e5/issues/57a2a2509278f0a62564a475596ca064849391682ae04ee12c1a02fd06e9c1d0,57a2a2509278f0a62564a475596ca064849391682ae04ee12c1a02fd06e9c1d0,cbca5d82d0961b33c8b838716b2505a1,2.0,opened,"CWE-141,CWE-142,CWE-143,CWE-146,CWE-149,CWE-150,CWE-157,CWE-566,CWE-89",IntegrationDataAccess/IntegrationDataAccess.cs,,SQL_NOT_CONSTANT,sql_injection:audit_non_constant_concat|c#,"1960 	            {
1961 	                StringBuilder selectSQL = new StringBuilder();
1962 	                selectSQL.Append(""SELECT MappingDefinition FROM Frs_def_integration_mapping im INNER JOIN Frs_def_integration i ON im.IntegrationLink_RecID = i.RecId WHERE Type=@type"");
1963 	                using (SqlConnection conn = (SqlConnection)this.GetConnection(DBAuth.ConnStringWithProvider(), DBAuth.TenantId))
1964 	                {
1965 	                    SqlCommand cmd = new SqlCommand(selectSQL.ToString(), conn);
1966 	                    cmd.Parameters.AddWithValue(""@type"", type);
","Calling ""SqlCommand"". Passing the tainted value ""selectSQL.ToString()"" to the SQL API may allow an attacker to inject SQL.","Calling ""ToString"". This call assigns ""selectSQL"" to ""<return value>"". Now ""<return value>"" is tainted.
Calling ""ToString"". This call returns a reference to ""<return value>"".
Use one of the following methods:
* Use a query-preparation API to safely construct the SQL query containing user-supplied values.
* Only concatenate a user-supplied value into a query if it has been checked against a whitelist of safe string values, or if it must be a Boolean or numeric type.

",IntegrationServer
20,Non-constant SQL,"An SQL statement is constructed by concatenating a non-constant string..Malicious or rogue values may alter the intent of the SQL query or command and cause incorrect behavior, leaked sensitive information, or a loss of data.",master,http://ivanti.polaris.synopsys.com/projects/e95bcef8-1a63-4b5b-a2e8-e2b0cee54d77/branches/15de2c52-d415-42e9-8b17-59a530bf8575/revisions/13a7ac9a-aa5f-4981-b23c-fd28ddfad0e5/issues/5b1edec8b8979dd08c0ce7db79a1e2482fe3dd2b733a9464fa1badb5cbf2725a,5b1edec8b8979dd08c0ce7db79a1e2482fe3dd2b733a9464fa1badb5cbf2725a,5bd088416d9b8afdd93ce1c101a4f3ec,2.0,opened,"CWE-141,CWE-142,CWE-143,CWE-146,CWE-149,CWE-150,CWE-157,CWE-566,CWE-89",IntegrationDataAccess/IntegrationDataAccess.cs,,SQL_NOT_CONSTANT,sql_injection:audit_non_constant_concat|c#,"1593 	                sql.Append(""UPDATE Frs_data_run_program_log "")
1594 	                    .Append(""SET [Status] = @Status, [LastModDateTime] = @LastModDateTime, [EndTime] = @EndTime, [Output] = @Output"");
1595 	                if (!string.IsNullOrEmpty(statistic.Message))
1596 	                    sql.Append("", [Message] = @Message"");
1597 	                sql.Append("" WHERE [RecId] = @RecId"");
1598 	                SqlCommand cmd = new SqlCommand(sql.ToString(), conn);
1599 	                DateTime now = DateTime.UtcNow;
","Calling ""SqlCommand"". Passing the tainted value ""sql.ToString()"" to the SQL API may allow an attacker to inject SQL.","Calling ""ToString"". This call assigns ""sql"" to ""<return value>"". Now ""<return value>"" is tainted.
Calling ""ToString"". This call returns a reference to ""<return value>"".
Use one of the following methods:
* Use a query-preparation API to safely construct the SQL query containing user-supplied values.
* Only concatenate a user-supplied value into a query if it has been checked against a whitelist of safe string values, or if it must be a Boolean or numeric type.

",IntegrationServer
21,Non-constant SQL,"An SQL statement is constructed by concatenating a non-constant string..Malicious or rogue values may alter the intent of the SQL query or command and cause incorrect behavior, leaked sensitive information, or a loss of data.",master,http://ivanti.polaris.synopsys.com/projects/e95bcef8-1a63-4b5b-a2e8-e2b0cee54d77/branches/15de2c52-d415-42e9-8b17-59a530bf8575/revisions/13a7ac9a-aa5f-4981-b23c-fd28ddfad0e5/issues/5d45252f513d641b69abbdbbf3a825bef1c1e7dd362a6f214c367f0f77514c37,5d45252f513d641b69abbdbbf3a825bef1c1e7dd362a6f214c367f0f77514c37,bcbe0b4afd5ff898cfc1ed730b6fb629,2.0,opened,"CWE-141,CWE-142,CWE-143,CWE-146,CWE-149,CWE-150,CWE-157,CWE-566,CWE-89",IntegrationDataAccess/IntegrationDataAccess.cs,,SQL_NOT_CONSTANT,sql_injection:audit_non_constant_concat|c#,"249 	            int ret = 0;
250 	            using (SqlConnection conn = (SqlConnection)this.GetConnection(DBAuth.ConnStringWithProvider(), DBAuth.TenantId))
251 	            {
252 	                using (SqlTransaction trans = conn.BeginTransaction())
253 	                {
254 	                    SqlCommand cmd = new SqlCommand(insertSql.ToString(), conn);
255 	                    cmd.Transaction = trans;
","Calling ""SqlCommand"". Passing the tainted value ""insertSql.ToString()"" to the SQL API may allow an attacker to inject SQL.","Calling ""ToString"". This call assigns ""insertSql"" to ""<return value>"". Now ""<return value>"" is tainted.
Calling ""ToString"". This call returns a reference to ""<return value>"".
Use one of the following methods:
* Use a query-preparation API to safely construct the SQL query containing user-supplied values.
* Only concatenate a user-supplied value into a query if it has been checked against a whitelist of safe string values, or if it must be a Boolean or numeric type.

",IntegrationServer
22,Explicit null dereferenced,Dereference of an explicit null value.A null pointer exception will occur.,master,http://ivanti.polaris.synopsys.com/projects/e95bcef8-1a63-4b5b-a2e8-e2b0cee54d77/branches/15de2c52-d415-42e9-8b17-59a530bf8575/revisions/4d324b91-7336-4b9f-b4d6-c29a48ceb332/issues/647ce0715a28dc4abd17cfb61b1328bff3303e0f8d55f153dda3fad07acb8431,647ce0715a28dc4abd17cfb61b1328bff3303e0f8d55f153dda3fad07acb8431,f9ccb5a5ed92ef594945318f0f324687,7.5,opened,CWE-476,XMLGenerator/GenerateXML.cs,,FORWARD_NULL,null_pointer_dereference_exception:constant_null|c#,"48 	
49 	                    writer.WriteStartElement(""BusinessObjectList"");
50 	                    // SchemaVersion=""1.0""
51 	                    writer.WriteAttributeString(""SchemaVersion"", ""1.0"");
52 	                    //xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
53 	                    writer.WriteAttributeString(""xmlns:xsi"", null, ""http://www.w3.org/2001/XMLSchema-instance"");
54 	                    // xsi:noNamespaceSchemaLocation=""HierarchicalObjects-1.0.xsd""
55 	                    writer.WriteAttributeString(""xsi:noNamespaceSchemaLocation"", null, ""HierarchicalObjects-1.0.xsd"");
56 	                    
57 	                    int number = XMLInput.StartingKeyNumber;
","Passing ""null"" to ""WriteAttributeString"", which dereferences it.",,IntegrationServer
23,Explicit null dereferenced,Dereference of an explicit null value.A null pointer exception will occur.,master,http://ivanti.polaris.synopsys.com/projects/e95bcef8-1a63-4b5b-a2e8-e2b0cee54d77/branches/15de2c52-d415-42e9-8b17-59a530bf8575/revisions/4d324b91-7336-4b9f-b4d6-c29a48ceb332/issues/65fcab6638a0cdeb216b3813b5a7a9a0faade8d47d733d9fa955c476a45613f5,65fcab6638a0cdeb216b3813b5a7a9a0faade8d47d733d9fa955c476a45613f5,ff16d0934619afca9837ea1970b600fd,7.5,opened,CWE-476,XMLGenerator/GenerateXML.cs,,FORWARD_NULL,null_pointer_dereference_exception:constant_null|c#,"385 	        }
386 	
387 	        private void WriteJournalNotesFields(XmlTextWriter writer)
388 	        {
389 	            writer.WriteStartElement(""Field"");
390 	            writer.WriteAttributeString(""Name"", null, ""RecId"");
391 	            writer.WriteValue(ODB.NewGuid());
392 	            writer.WriteEndElement();
393 	
394 	            writer.WriteStartElement(""Field"");
","Passing ""null"" to ""WriteAttributeString"", which dereferences it.",,IntegrationServer
24,Non-constant SQL,"An SQL statement is constructed by concatenating a non-constant string..Malicious or rogue values may alter the intent of the SQL query or command and cause incorrect behavior, leaked sensitive information, or a loss of data.",master,http://ivanti.polaris.synopsys.com/projects/e95bcef8-1a63-4b5b-a2e8-e2b0cee54d77/branches/15de2c52-d415-42e9-8b17-59a530bf8575/revisions/13a7ac9a-aa5f-4981-b23c-fd28ddfad0e5/issues/676f11847c1d253d21193105d13e1a84dc0c4cdd7b82224de5b82811db5c4b82,676f11847c1d253d21193105d13e1a84dc0c4cdd7b82224de5b82811db5c4b82,fe7201990b4fdc6187c86d066ed8ac28,2.0,opened,"CWE-141,CWE-142,CWE-143,CWE-146,CWE-149,CWE-150,CWE-157,CWE-566,CWE-89",IntegrationDataAccess/IntegrationDataAccess.cs,,SQL_NOT_CONSTANT,sql_injection:audit_non_constant_concat|c#,"172 	            StringBuilder selectSQL = new StringBuilder();
173 	            selectSQL.Append(""SELECT IsExport FROM Frs_def_integration WHERE RecId = @Id"");
174 	
175 	            using (SqlConnection conn = (SqlConnection)this.GetConnection(DBAuth.ConnStringWithProvider(), DBAuth.TenantId))
176 	            {
177 	                SqlCommand cmd = new SqlCommand(selectSQL.ToString(), conn);
178 	                cmd.Parameters.AddWithValue(""@Id"", integrationId);
","Calling ""SqlCommand"". Passing the tainted value ""selectSQL.ToString()"" to the SQL API may allow an attacker to inject SQL.","Calling ""ToString"". This call assigns ""selectSQL"" to ""<return value>"". Now ""<return value>"" is tainted.
Calling ""ToString"". This call returns a reference to ""<return value>"".
Use one of the following methods:
* Use a query-preparation API to safely construct the SQL query containing user-supplied values.
* Only concatenate a user-supplied value into a query if it has been checked against a whitelist of safe string values, or if it must be a Boolean or numeric type.

",IntegrationServer
25,Dereference null return value,"Return value of function which returns null is dereferenced without checking.If the function actually returns a null reference, a null reference exception will occur.",master,http://ivanti.polaris.synopsys.com/projects/e95bcef8-1a63-4b5b-a2e8-e2b0cee54d77/branches/15de2c52-d415-42e9-8b17-59a530bf8575/revisions/4d324b91-7336-4b9f-b4d6-c29a48ceb332/issues/7880c1c5c5a3d72ca813e8f5cfb5d5e82dd24e6d88390c2a64a32f5e2a312bba,7880c1c5c5a3d72ca813e8f5cfb5d5e82dd24e6d88390c2a64a32f5e2a312bba,565cf970704405ad616b96e7e211ac3a,7.5,opened,CWE-476,tools/Message_Generator_Utility/Message_Generator_Utility/Program.cs,,NULL_RETURNS,null_pointer_dereference_exception:return_value|c#,"36 	                    if (deletefromPath)
37 	                    {
38 	                        deletefiles(InvoiceBlobPath);
39 	                        deletefiles(InvoiceMessagePath);
40 	                    }
41 	                    InvoiceGenerator(UnoTenantId, Tenant_id, NoOfMessage, InvoiceMessagePath, InvoiceBlobPath);
42 	                }
43 	                if (TypeOFMessage== ""Device"")
44 	                {
45 	                    if (deletefromPath)
","Throws an exception when ""UnoTenantId"", a pointer that might be ""null"", is ""null"" when calling ""InvoiceGenerator"".",,IntegrationServer
26,Non-constant SQL,"An SQL statement is constructed by concatenating a non-constant string..Malicious or rogue values may alter the intent of the SQL query or command and cause incorrect behavior, leaked sensitive information, or a loss of data.",master,http://ivanti.polaris.synopsys.com/projects/e95bcef8-1a63-4b5b-a2e8-e2b0cee54d77/branches/15de2c52-d415-42e9-8b17-59a530bf8575/revisions/13a7ac9a-aa5f-4981-b23c-fd28ddfad0e5/issues/7beb6cc1ce182eeb6ba664a014b8cf843cb901c257a3fe0a9c4a9c5c967264a3,7beb6cc1ce182eeb6ba664a014b8cf843cb901c257a3fe0a9c4a9c5c967264a3,992777f74849abcfc2b98077c3041b09,2.0,opened,"CWE-141,CWE-142,CWE-143,CWE-146,CWE-149,CWE-150,CWE-157,CWE-566,CWE-89",IntegrationDataAccess/IntegrationDataAccess.cs,,SQL_NOT_CONSTANT,sql_injection:audit_non_constant_concat|c#,"1148 	
1149 	                builder.Append(""SELECT * "")
1150 	                       .Append(""FROM ScheduleEntry "")
1151 	                       .Append(""WHERE [RecId] = @ScheduleRecId"");
1153 	                SqlCommand cmd = new SqlCommand(builder.ToString(), conn);
1154 	                cmd.Parameters.AddWithValue(""@ScheduleRecId"", scheduleRecId);
","Calling ""SqlCommand"". Passing the tainted value ""builder.ToString()"" to the SQL API may allow an attacker to inject SQL.","Calling ""ToString"". This call assigns ""builder"" to ""<return value>"". Now ""<return value>"" is tainted.
Calling ""ToString"". This call returns a reference to ""<return value>"".
Use one of the following methods:
* Use a query-preparation API to safely construct the SQL query containing user-supplied values.
* Only concatenate a user-supplied value into a query if it has been checked against a whitelist of safe string values, or if it must be a Boolean or numeric type.

",IntegrationServer
27,Explicit null dereferenced,Dereference of an explicit null value.A null pointer exception will occur.,master,http://ivanti.polaris.synopsys.com/projects/e95bcef8-1a63-4b5b-a2e8-e2b0cee54d77/branches/15de2c52-d415-42e9-8b17-59a530bf8575/revisions/4d324b91-7336-4b9f-b4d6-c29a48ceb332/issues/7cfe2475f11d3b66d8541cb98116e8a3313d65dcc65f61ff375e91d1727009c9,7cfe2475f11d3b66d8541cb98116e8a3313d65dcc65f61ff375e91d1727009c9,c07a6410f7407e14d8769a602cd52187,7.5,opened,CWE-476,XMLGenerator/GenerateXML.cs,,FORWARD_NULL,null_pointer_dereference_exception:constant_null|c#,"309 	        }
310 	
311 	        private void WriteProblemFields(XmlTextWriter writer, int number)
312 	        {
313 	            writer.WriteStartElement(""Field"");
314 	            writer.WriteAttributeString(""Name"", null, ""ProblemNumber"");
315 	            writer.WriteValue(number.ToString());
316 	            writer.WriteEndElement();
317 	
318 	            writer.WriteStartElement(""Field"");
","Passing ""null"" to ""WriteAttributeString"", which dereferences it.",,IntegrationServer
28,Resource leak on an exceptional path,"Leak of a system resource such as streams, channels, or other resources on an exception path (probably error handling).The system resource will not be reclaimed and reused, reducing the future availability of the resource.",master,http://ivanti.polaris.synopsys.com/projects/e95bcef8-1a63-4b5b-a2e8-e2b0cee54d77/branches/15de2c52-d415-42e9-8b17-59a530bf8575/revisions/4d324b91-7336-4b9f-b4d6-c29a48ceb332/issues/7e0dad450b4974b62f543622ea299fc1a9aea28659aef0d9d13a2559dd03be8a,7e0dad450b4974b62f543622ea299fc1a9aea28659aef0d9d13a2559dd03be8a,cccca6f5744ce7fbd0fdbb3f6c2f121d,5.5,opened,CWE-404,IntegrationDataAccess/IntegrationDataAccess.cs,,RESOURCE_LEAK,resource_leak:exceptional_path|c#,"92 	                q.AddFields(IntegrationObject.Fields());
94 	                q.AddWhere(r => r.tf[""Active""] == 1);
95 	
96 	                q.Connection = conn;
97 	                foreach (Record r in q)
98 	                {
","Variable ""q"" going out of scope leaks the resource it refers to.","Resource ""q"" is not closed or saved in ""AddWhere"".
Throwing ""System.ApplicationException"" from call to ""AddWhere""; exiting method with uncaught exception.
",IntegrationServer
29,Non-constant SQL,"An SQL statement is constructed by concatenating a non-constant string..Malicious or rogue values may alter the intent of the SQL query or command and cause incorrect behavior, leaked sensitive information, or a loss of data.",master,http://ivanti.polaris.synopsys.com/projects/e95bcef8-1a63-4b5b-a2e8-e2b0cee54d77/branches/15de2c52-d415-42e9-8b17-59a530bf8575/revisions/13a7ac9a-aa5f-4981-b23c-fd28ddfad0e5/issues/86fcb4efee440d35fd022c4bbb8cf68f2084d08468e02f204ada24108aaa09aa,86fcb4efee440d35fd022c4bbb8cf68f2084d08468e02f204ada24108aaa09aa,2f4e699641fdd522fb2e13a52493473c,2.0,opened,"CWE-141,CWE-142,CWE-143,CWE-146,CWE-149,CWE-150,CWE-157,CWE-566,CWE-89",IntegrationDataAccess/IntegrationDataAccess.cs,,SQL_NOT_CONSTANT,sql_injection:audit_non_constant_concat|c#,"678 	            {
679 	                var columnNames = GetColumnNames(conn, DBAuth.TenantId, ""Frs_data_integration_history"");
680 	                StringBuilder sql = new StringBuilder();
681 	                sql.Append(""SELECT [StartTime] FROM Frs_data_integration_history "")
682 	                    .Append(""WHERE [QueueLink_RecID] = @RecId"");
683 	                SqlCommand cmd = new SqlCommand(sql.ToString(), conn);
684 	                cmd.Parameters.AddWithValue(""@RecId"", batchinfo.EventRecId);
","Calling ""SqlCommand"". Passing the tainted value ""sql.ToString()"" to the SQL API may allow an attacker to inject SQL.","Calling ""ToString"". This call assigns ""sql"" to ""<return value>"". Now ""<return value>"" is tainted.
Calling ""ToString"". This call returns a reference to ""<return value>"".
Use one of the following methods:
* Use a query-preparation API to safely construct the SQL query containing user-supplied values.
* Only concatenate a user-supplied value into a query if it has been checked against a whitelist of safe string values, or if it must be a Boolean or numeric type.

",IntegrationServer
30,Dereference null return value,"Return value of function which returns null is dereferenced without checking.If the function actually returns a null reference, a null reference exception will occur.",master,http://ivanti.polaris.synopsys.com/projects/e95bcef8-1a63-4b5b-a2e8-e2b0cee54d77/branches/15de2c52-d415-42e9-8b17-59a530bf8575/revisions/4d324b91-7336-4b9f-b4d6-c29a48ceb332/issues/87ef4df1d9fa4957f09a6f469299a72e60963f77abcd06ff9f29b7e9cb1c21ac,87ef4df1d9fa4957f09a6f469299a72e60963f77abcd06ff9f29b7e9cb1c21ac,261990c0de18f1b67e4fbd234b82ea3e,7.5,opened,CWE-476,tools/Message_Generator_Utility/Message_Generator_Utility/Program.cs,,NULL_RETURNS,null_pointer_dereference_exception:return_value|c#,"36 	                    if (deletefromPath)
37 	                    {
38 	                        deletefiles(InvoiceBlobPath);
39 	                        deletefiles(InvoiceMessagePath);
40 	                    }
41 	                    InvoiceGenerator(UnoTenantId, Tenant_id, NoOfMessage, InvoiceMessagePath, InvoiceBlobPath);
42 	                }
43 	                if (TypeOFMessage== ""Device"")
","Throws an exception when ""InvoiceMessagePath"", a pointer that might be ""null"", is ""null"" when calling ""deletefiles"".",,IntegrationServer
31,Dereference null return value,"Return value of function which returns null is dereferenced without checking.If the function actually returns a null reference, a null reference exception will occur.",master,http://ivanti.polaris.synopsys.com/projects/e95bcef8-1a63-4b5b-a2e8-e2b0cee54d77/branches/15de2c52-d415-42e9-8b17-59a530bf8575/revisions/4d324b91-7336-4b9f-b4d6-c29a48ceb332/issues/8c0051e35ae7d553576ad8ad69aca7cad9e980e1fbcb4065f8093d8987c3a13f,8c0051e35ae7d553576ad8ad69aca7cad9e980e1fbcb4065f8093d8987c3a13f,ba83e8e43d1986e53c6e55ac456e81cd,7.5,opened,CWE-476,tools/Message_Generator_Utility/Message_Generator_Utility/Program.cs,,NULL_RETURNS,null_pointer_dereference_exception:return_value|c#,"54 	                    if (deletefromPath)
55 	                    {
56 	                        deletefiles(softwareBlobPath);
57 	                        deletefiles(softwareMessagePath);
58 	                    }
59 	                    SWGenerator(UnoTenantId, Tenant_id, NoOfMessage, softwareMessagePath, softwareBlobPath);
60 	                }
","Throws an exception when ""softwareBlobPath"", a pointer that might be ""null"", is ""null"" when calling ""deletefiles"".",,IntegrationServer
32,Explicit null dereferenced,Dereference of an explicit null value.A null pointer exception will occur.,master,http://ivanti.polaris.synopsys.com/projects/e95bcef8-1a63-4b5b-a2e8-e2b0cee54d77/branches/15de2c52-d415-42e9-8b17-59a530bf8575/revisions/4d324b91-7336-4b9f-b4d6-c29a48ceb332/issues/8cd61d1b5b8154a247b4ec15b529d42225639189bc7d4dce44d9dc52551ac70b,8cd61d1b5b8154a247b4ec15b529d42225639189bc7d4dce44d9dc52551ac70b,17500f4cf8b84459047b8e1c2ed0d3d7,7.5,opened,CWE-476,XMLGenerator/GenerateXML.cs,,FORWARD_NULL,null_pointer_dereference_exception:constant_null|c#,"261 	        }
262 	
263 	        private void WriteChangeFields(XmlTextWriter writer, int number)
264 	        {
265 	            writer.WriteStartElement(""Field"");
266 	            writer.WriteAttributeString(""Name"", null, ""RequestorLink"");
267 	            writer.WriteValue(""John M Doe"");
268 	            writer.WriteEndElement();
269 	
270 	            writer.WriteStartElement(""Field"");
","Passing ""null"" to ""WriteAttributeString"", which dereferences it.",,IntegrationServer
33,Dereference null return value,"Return value of function which returns null is dereferenced without checking.If the function actually returns a null reference, a null reference exception will occur.",master,http://ivanti.polaris.synopsys.com/projects/e95bcef8-1a63-4b5b-a2e8-e2b0cee54d77/branches/15de2c52-d415-42e9-8b17-59a530bf8575/revisions/4d324b91-7336-4b9f-b4d6-c29a48ceb332/issues/8ee1572a25d3f7ac27bea533ec261bc45a6a6c2828cc81c5265a2a428956985d,8ee1572a25d3f7ac27bea533ec261bc45a6a6c2828cc81c5265a2a428956985d,51712027079551239ea712f7bc97f6a4,7.5,opened,CWE-476,tools/Message_Generator_Utility/Message_Generator_Utility/Program.cs,,NULL_RETURNS,null_pointer_dereference_exception:return_value|c#,"45 	                    if (deletefromPath)
46 	                    {
47 	                        deletefiles(DeviceBlobPath);
48 	                        deletefiles(DeviceMessagePath);
49 	                    }
50 	                    DeviceGenerator(UnoTenantId, Tenant_id, NoOfMessage, DeviceMessagePath, DeviceBlobPath);
51 	                }
","Throws an exception when ""DeviceBlobPath"", a pointer that might be ""null"", is ""null"" when calling ""deletefiles"".",,IntegrationServer
34,Non-constant SQL,"An SQL statement is constructed by concatenating a non-constant string..Malicious or rogue values may alter the intent of the SQL query or command and cause incorrect behavior, leaked sensitive information, or a loss of data.",master,http://ivanti.polaris.synopsys.com/projects/e95bcef8-1a63-4b5b-a2e8-e2b0cee54d77/branches/15de2c52-d415-42e9-8b17-59a530bf8575/revisions/13a7ac9a-aa5f-4981-b23c-fd28ddfad0e5/issues/939b35aaceaef084552c85afad955439a5e8d9675de8e21c8aca5e63c76bb7bb,939b35aaceaef084552c85afad955439a5e8d9675de8e21c8aca5e63c76bb7bb,01bfeba71ed47e3b3fb7761be0a392b6,2.0,opened,"CWE-141,CWE-142,CWE-143,CWE-146,CWE-149,CWE-150,CWE-157,CWE-566,CWE-89",IntegrationDataAccess/IntegrationDataAccess.cs,,SQL_NOT_CONSTANT,sql_injection:audit_non_constant_concat|c#,"1569 	            {
1570 	                StringBuilder sql = new StringBuilder();
1571 	                sql.Append(""UPDATE Frs_data_run_program_log "")
1572 	                    .Append(""SET [Status] = @Status, [LastModDateTime] = @LastModDateTime, [EndTime] = @EndTime, [Output] = @Output"");
1573 	                sql.Append("" WHERE [RecId] = @RecId"");
1574 	                SqlCommand cmd = new SqlCommand(sql.ToString(), conn);
1575 	                DateTime now = DateTime.UtcNow;
","Calling ""SqlCommand"". Passing the tainted value ""sql.ToString()"" to the SQL API may allow an attacker to inject SQL.","Calling ""ToString"". This call assigns ""sql"" to ""<return value>"". Now ""<return value>"" is tainted.
Calling ""ToString"". This call returns a reference to ""<return value>"".
Use one of the following methods:
* Use a query-preparation API to safely construct the SQL query containing user-supplied values.
* Only concatenate a user-supplied value into a query if it has been checked against a whitelist of safe string values, or if it must be a Boolean or numeric type.

",IntegrationServer
35,Non-constant SQL,"An SQL statement is constructed by concatenating a non-constant string..Malicious or rogue values may alter the intent of the SQL query or command and cause incorrect behavior, leaked sensitive information, or a loss of data.",master,http://ivanti.polaris.synopsys.com/projects/e95bcef8-1a63-4b5b-a2e8-e2b0cee54d77/branches/15de2c52-d415-42e9-8b17-59a530bf8575/revisions/13a7ac9a-aa5f-4981-b23c-fd28ddfad0e5/issues/946d9e6a3be1cf4ed42a84f62e0b81236896bb4f8578ac6e1a1e0476d041cafe,946d9e6a3be1cf4ed42a84f62e0b81236896bb4f8578ac6e1a1e0476d041cafe,26c8063b9f48195483eb6cdbf3ca534a,2.0,opened,"CWE-141,CWE-142,CWE-143,CWE-146,CWE-149,CWE-150,CWE-157,CWE-566,CWE-89",IntegrationDataAccess/IntegrationDataAccess.cs,,SQL_NOT_CONSTANT,sql_injection:audit_non_constant_concat|c#,"431 	                    {
432 	                        StringBuilder sql = new StringBuilder();
433 	                        sql.Append(""UPDATE Frs_ops_integration_queue SET [Status] = @Status, "")
434 	                            .Append(""LastModDateTime = @LastModDateTime "")
435 	                            .Append(""where RecId = @RecId"");
436 	                        cmd.CommandText = sql.ToString();
","Calling ""CommandText.set"". Passing the tainted value ""sql.ToString()"" to the SQL API may allow an attacker to inject SQL. (The virtual call resolves to ""System.Data.SqlClient.SqlCommand.CommandText.set(System.String)"".)","Calling ""ToString"". This call assigns ""sql"" to ""<return value>"". Now ""<return value>"" is tainted.
Calling ""ToString"". This call returns a reference to ""<return value>"".
Use one of the following methods:
* Use a query-preparation API to safely construct the SQL query containing user-supplied values.
* Only concatenate a user-supplied value into a query if it has been checked against a whitelist of safe string values, or if it must be a Boolean or numeric type.

",IntegrationServer
36,Non-constant SQL,"An SQL statement is constructed by concatenating a non-constant string..Malicious or rogue values may alter the intent of the SQL query or command and cause incorrect behavior, leaked sensitive information, or a loss of data.",master,http://ivanti.polaris.synopsys.com/projects/e95bcef8-1a63-4b5b-a2e8-e2b0cee54d77/branches/15de2c52-d415-42e9-8b17-59a530bf8575/revisions/13a7ac9a-aa5f-4981-b23c-fd28ddfad0e5/issues/9aa5c1fcf67709b2d41c36ca2f4c491f40f458d8a828331f30d9d02f6f108e88,9aa5c1fcf67709b2d41c36ca2f4c491f40f458d8a828331f30d9d02f6f108e88,8bd13140c23cce813e8a3681717e24ad,2.0,opened,"CWE-141,CWE-142,CWE-143,CWE-146,CWE-149,CWE-150,CWE-157,CWE-566,CWE-89",IntegrationDataAccess/IntegrationDataAccess.cs,,SQL_NOT_CONSTANT,sql_injection:audit_non_constant_concat|c#,"1753 	                sql.Append(""UPDATE [Frs_ops_integration_queue] "")
1754 	                    .Append(""SET [Status]='"").Append(RequestStatus.Queued).Append(""'"")
1755 	                    .Append("" WHERE [Comments] = @messageId "")
1756 	                    .Append(""AND [Status]= '"").Append(RequestStatus.WaitForData).Append(""'"");
1758 	                SqlCommand cmd = new SqlCommand(sql.ToString(), conn);
1759 	                cmd.Parameters.AddWithValue(""@messageId"", messageId);
","Calling ""SqlCommand"". Passing the tainted value ""sql.ToString()"" to the SQL API may allow an attacker to inject SQL.","Use one of the following methods:
* Use a query-preparation API to safely construct the SQL query containing user-supplied values.
* Only concatenate a user-supplied value into a query if it has been checked against a whitelist of safe string values, or if it must be a Boolean or numeric type.

Calling ""ToString"". This call assigns ""sql"" to ""<return value>"". Now ""<return value>"" is tainted.
Calling ""ToString"". This call returns a reference to ""<return value>"".
",IntegrationServer
37,Dereference null return value,"Return value of function which returns null is dereferenced without checking.If the function actually returns a null reference, a null reference exception will occur.",master,http://ivanti.polaris.synopsys.com/projects/e95bcef8-1a63-4b5b-a2e8-e2b0cee54d77/branches/15de2c52-d415-42e9-8b17-59a530bf8575/revisions/4d324b91-7336-4b9f-b4d6-c29a48ceb332/issues/9b1229992b8f550392c74e902af7a5c0e836076d6c0271552321d4eac3a22b9f,9b1229992b8f550392c74e902af7a5c0e836076d6c0271552321d4eac3a22b9f,b67b6434b57b1aa4feaa38fc9d66dfbf,7.5,opened,CWE-476,tools/Message_Generator_Utility/Message_Generator_Utility/Program.cs,,NULL_RETURNS,null_pointer_dereference_exception:return_value|c#,"45 	                    if (deletefromPath)
46 	                    {
47 	                        deletefiles(DeviceBlobPath);
48 	                        deletefiles(DeviceMessagePath);
49 	                    }
50 	                    DeviceGenerator(UnoTenantId, Tenant_id, NoOfMessage, DeviceMessagePath, DeviceBlobPath);
51 	                }
52 	                if (TypeOFMessage == ""Software"")
","Throws an exception when ""DeviceMessagePath"", a pointer that might be ""null"", is ""null"" when calling ""deletefiles"".",,IntegrationServer
38,Non-constant SQL,"An SQL statement is constructed by concatenating a non-constant string..Malicious or rogue values may alter the intent of the SQL query or command and cause incorrect behavior, leaked sensitive information, or a loss of data.",master,http://ivanti.polaris.synopsys.com/projects/e95bcef8-1a63-4b5b-a2e8-e2b0cee54d77/branches/15de2c52-d415-42e9-8b17-59a530bf8575/revisions/13a7ac9a-aa5f-4981-b23c-fd28ddfad0e5/issues/9da81fe238f19181f427c68ebfcb9982949f9a96f444d1ec8d875d3e0ed4fde3,9da81fe238f19181f427c68ebfcb9982949f9a96f444d1ec8d875d3e0ed4fde3,43a76172ce9e591a2c028cdb754347fe,2.0,opened,"CWE-141,CWE-142,CWE-143,CWE-146,CWE-149,CWE-150,CWE-157,CWE-566,CWE-89",IntegrationDataAccess/IntegrationDataAccess.cs,,SQL_NOT_CONSTANT,sql_injection:audit_non_constant_concat|c#,"1718 	            StringBuilder selectSQL = new StringBuilder();
1719 	            selectSQL.Append(""SELECT a.ATTACHNAME, f.FileBytes, a.RecID FROM Attachment a left join FusionAttachments f on a.RecID = f.RecID WHERE a.ParentLink_RecID = @Id"");
1720 	
1721 	            using (SqlConnection conn = (SqlConnection)this.GetConnection(DBAuth.ConnStringWithProvider(), DBAuth.TenantId))
1722 	            {
1723 	                SqlCommand cmd = new SqlCommand(selectSQL.ToString(), conn);
1724 	                cmd.Parameters.AddWithValue(""@Id"", connectionId);
","Calling ""SqlCommand"". Passing the tainted value ""selectSQL.ToString()"" to the SQL API may allow an attacker to inject SQL.","Calling ""ToString"". This call assigns ""selectSQL"" to ""<return value>"". Now ""<return value>"" is tainted.
Calling ""ToString"". This call returns a reference to ""<return value>"".
Use one of the following methods:
* Use a query-preparation API to safely construct the SQL query containing user-supplied values.
* Only concatenate a user-supplied value into a query if it has been checked against a whitelist of safe string values, or if it must be a Boolean or numeric type.

",IntegrationServer
39,Non-constant SQL,"An SQL statement is constructed by concatenating a non-constant string..Malicious or rogue values may alter the intent of the SQL query or command and cause incorrect behavior, leaked sensitive information, or a loss of data.",master,http://ivanti.polaris.synopsys.com/projects/e95bcef8-1a63-4b5b-a2e8-e2b0cee54d77/branches/15de2c52-d415-42e9-8b17-59a530bf8575/revisions/13a7ac9a-aa5f-4981-b23c-fd28ddfad0e5/issues/9eedea2345ef92c171c7d9ce2b5704b10266c2dec0266533b1b8d277f31f18a9,9eedea2345ef92c171c7d9ce2b5704b10266c2dec0266533b1b8d277f31f18a9,012a0893ff6a56ca307695697a41982a,2.0,opened,"CWE-141,CWE-142,CWE-143,CWE-146,CWE-149,CWE-150,CWE-157,CWE-566,CWE-89",IntegrationDataAccess/IntegrationDataAccess.cs,,SQL_NOT_CONSTANT,sql_injection:audit_non_constant_concat|c#,"830 	                    }
831 	                    else
832 	                    {
833 	                        sql.Append("")"");
834 	                    }
835 	                    SqlCommand cmd = new SqlCommand(sql.ToString(), conn);
","Calling ""SqlCommand"". Passing the tainted value ""sql.ToString()"" to the SQL API may allow an attacker to inject SQL.","Calling ""ToString"". This call assigns ""sql"" to ""<return value>"". Now ""<return value>"" is tainted.
Calling ""ToString"". This call returns a reference to ""<return value>"".
Use one of the following methods:
* Use a query-preparation API to safely construct the SQL query containing user-supplied values.
* Only concatenate a user-supplied value into a query if it has been checked against a whitelist of safe string values, or if it must be a Boolean or numeric type.

",IntegrationServer
40,Resource leak on an exceptional path,"Leak of a system resource such as streams, channels, or other resources on an exception path (probably error handling).The system resource will not be reclaimed and reused, reducing the future availability of the resource.",master,http://ivanti.polaris.synopsys.com/projects/e95bcef8-1a63-4b5b-a2e8-e2b0cee54d77/branches/15de2c52-d415-42e9-8b17-59a530bf8575/revisions/4d324b91-7336-4b9f-b4d6-c29a48ceb332/issues/a0806e3954d8971fdc5f2f4d32049434644c70e546184aff9fe0dac0b89b63f2,a0806e3954d8971fdc5f2f4d32049434644c70e546184aff9fe0dac0b89b63f2,69584986051368fd9377a7abb3b49f89,5.5,opened,CWE-404,IntegrationDataAccess/IntegrationDataAccess.cs,,RESOURCE_LEAK,resource_leak:exceptional_path|c#,"117 	                q.AddFields(IntegrationObject.Fields());
119 	                q.AddWhere(r => (r.tf[""RecId""] == id && r.tf[""Active""] == 1));
120 	
121 	                q.Connection = conn;
122 	                foreach (Record r in q)
123 	                {
","Variable ""q"" going out of scope leaks the resource it refers to.","Resource ""q"" is not closed or saved in ""AddWhere"".
Throwing ""System.ApplicationException"" from call to ""AddWhere""; exiting method with uncaught exception.
",IntegrationServer
41,Hardcoded credentials in configuration file,The credentials value is stored in a configuration file..Having hardcoded credentials in configuration files accessible to potentially malicious users leads an attacker using those credential to gain access to the application's data and services.,master,http://ivanti.polaris.synopsys.com/projects/e95bcef8-1a63-4b5b-a2e8-e2b0cee54d77/branches/15de2c52-d415-42e9-8b17-59a530bf8575/revisions/6bfbc409-2c3f-4c7a-820a-ae63226652ce/issues/a3532b58281ffb96d1187ec6c0e90582ec064236f24b786653a04270d3ea5a60,a3532b58281ffb96d1187ec6c0e90582ec064236f24b786653a04270d3ea5a60,4d0aa299a2f5f44472bcc3144bf66d97,2.0,opened,"CWE-260,CWE-798",IntegrationDataAccess/bin/Release/System.IdentityModel.Tokens.Jwt.xml,,CONFIG.HARDCODED_CREDENTIALS_AUDIT,hardcoded_credentials:hardcoded_credentials_audit|c#,"1427 	        <member name=""M:System.IdentityModel.Tokens.JwtSecurityTokenHandler.ResolveIssuerSigningKey(System.String,System.IdentityModel.Tokens.SecurityToken,System.IdentityModel.Tokens.SecurityKeyIdentifier,System.IdentityModel.Tokens.TokenValidationParameters)"">
1428 	            <summary>
1429 	            Returns a <see cref=""T:System.IdentityModel.Tokens.SecurityKey""/> to use when validating the signature of a token.
1430 	            </summary>
1431 	            <param name=""token"">the <see cref=""T:System.String""/> representation of the token that is being validated.</param>
1432 	            <param name=""securityToken"">the <SecurityToken> that is being validated.</SecurityToken></param>
1433 	            <param name=""keyIdentifier"">the <see cref=""T:System.IdentityModel.Tokens.SecurityKeyIdentifier""/> found in the token.</param>
",The credential is hardcoded in the configuration file.,"Private credentials should be configured in a hardware security module. When other credentials are stored in configuration files, the files should not be checked into the code repository. When the application is deployed, the credentials should be baked in the image for deployment and only stored as environment variables. Remember that development and test credentials must also differ from production credentials.
",IntegrationServer
42,Explicit null dereferenced,Dereference of an explicit null value.A null pointer exception will occur.,master,http://ivanti.polaris.synopsys.com/projects/e95bcef8-1a63-4b5b-a2e8-e2b0cee54d77/branches/15de2c52-d415-42e9-8b17-59a530bf8575/revisions/4d324b91-7336-4b9f-b4d6-c29a48ceb332/issues/b6112d95278142845a2ec3c1fab7725a9bbc81579a999a051bf51abf2ff12cab,b6112d95278142845a2ec3c1fab7725a9bbc81579a999a051bf51abf2ff12cab,12104dcea054dc6e28e5a0d75e2cd0d2,7.5,opened,CWE-476,XMLGenerator/GenerateXML.cs,,FORWARD_NULL,null_pointer_dereference_exception:constant_null|c#,"418 	        }
419 	
420 	        private void WriteJournalEmailFields(XmlTextWriter writer)
421 	        {
422 	            writer.WriteStartElement(""Field"");
423 	            writer.WriteAttributeString(""Name"", null, ""RecId"");
424 	            writer.WriteValue(ODB.NewGuid());
425 	            writer.WriteEndElement();
426 	
427 	            writer.WriteStartElement(""Field"");
","Passing ""null"" to ""WriteAttributeString"", which dereferences it.",,IntegrationServer
43,Non-constant SQL,"An SQL statement is constructed by concatenating a non-constant string..Malicious or rogue values may alter the intent of the SQL query or command and cause incorrect behavior, leaked sensitive information, or a loss of data.",master,http://ivanti.polaris.synopsys.com/projects/e95bcef8-1a63-4b5b-a2e8-e2b0cee54d77/branches/15de2c52-d415-42e9-8b17-59a530bf8575/revisions/13a7ac9a-aa5f-4981-b23c-fd28ddfad0e5/issues/b6bc6ed79845b405836b5c7043116eb00eb052ade4c29d311e5598f335393589,b6bc6ed79845b405836b5c7043116eb00eb052ade4c29d311e5598f335393589,59e2fb0ad0a31c75d0d1977fd37593b4,2.0,opened,"CWE-141,CWE-142,CWE-143,CWE-146,CWE-149,CWE-150,CWE-157,CWE-566,CWE-89",IntegrationDataAccess/IntegrationDataAccess.cs,,SQL_NOT_CONSTANT,sql_injection:audit_non_constant_concat|c#,"1090 	                    .Append(""@ParentLink_RecID, @ParentLink_Category, (SELECT StartTime FROM [Frs_ops_integration_queue] WHERE [RecId] = @EventRecId), "")
1091 	                    .Append(""@LogType, @SourceID, @TargetID, @Message) "")
1092 	                    .Append(""ELSE UPDATE Frs_data_integration_log SET [Message] = @Message, [LastModDateTime] = @LastModDateTime, [LogType] = @LogType, [TargetID] = @TargetID, "")
1093 	                    .Append(""[StartTime] = (SELECT StartTime FROM [Frs_ops_integration_queue] WHERE [RecId] = @EventRecId) "")
1094 	                    .Append(""WHERE ParentLink_RecID = @ParentLink_RecID AND SourceID = @SourceID"");
1095 	                SqlCommand cmd = new SqlCommand(sql.ToString(), conn);
1096 	                DateTime now = DateTime.UtcNow;
","Calling ""SqlCommand"". Passing the tainted value ""sql.ToString()"" to the SQL API may allow an attacker to inject SQL.","Calling ""ToString"". This call assigns ""sql"" to ""<return value>"". Now ""<return value>"" is tainted.
Calling ""ToString"". This call returns a reference to ""<return value>"".
Use one of the following methods:
* Use a query-preparation API to safely construct the SQL query containing user-supplied values.
* Only concatenate a user-supplied value into a query if it has been checked against a whitelist of safe string values, or if it must be a Boolean or numeric type.

",IntegrationServer
44,Non-constant SQL,"An SQL statement is constructed by concatenating a non-constant string..Malicious or rogue values may alter the intent of the SQL query or command and cause incorrect behavior, leaked sensitive information, or a loss of data.",master,http://ivanti.polaris.synopsys.com/projects/e95bcef8-1a63-4b5b-a2e8-e2b0cee54d77/branches/15de2c52-d415-42e9-8b17-59a530bf8575/revisions/13a7ac9a-aa5f-4981-b23c-fd28ddfad0e5/issues/b9837c61c87f801581172bc5ac5672e892b1f9132270eaaf7cc5294fe0641595,b9837c61c87f801581172bc5ac5672e892b1f9132270eaaf7cc5294fe0641595,e6eaf78f0a1babbd22fe0b26d625ee17,2.0,opened,"CWE-141,CWE-142,CWE-143,CWE-146,CWE-149,CWE-150,CWE-157,CWE-566,CWE-89",IntegrationDataAccess/IntegrationDataAccess.cs,,SQL_NOT_CONSTANT,sql_injection:audit_non_constant_concat|c#,"1866 	                StringBuilder selectSQL = new StringBuilder();
1867 	                selectSQL.Append(""SELECT Enabled FROM IvantiCloudAssetImportConfig WHERE Type=@type"");
1868 	
1869 	                using (SqlConnection conn = (SqlConnection)this.GetConnection(DBAuth.ConnStringWithProvider(), DBAuth.TenantId))
1870 	                {
1871 	                    SqlCommand cmd = new SqlCommand(selectSQL.ToString(), conn);
1872 	                    cmd.Parameters.AddWithValue(""@type"", type);
","Calling ""SqlCommand"". Passing the tainted value ""selectSQL.ToString()"" to the SQL API may allow an attacker to inject SQL.","Calling ""ToString"". This call assigns ""selectSQL"" to ""<return value>"". Now ""<return value>"" is tainted.
Calling ""ToString"". This call returns a reference to ""<return value>"".
Use one of the following methods:
* Use a query-preparation API to safely construct the SQL query containing user-supplied values.
* Only concatenate a user-supplied value into a query if it has been checked against a whitelist of safe string values, or if it must be a Boolean or numeric type.

",IntegrationServer
45,Hardcoded credentials in configuration file,The credentials value is stored in a configuration file..Having hardcoded credentials in configuration files accessible to potentially malicious users leads an attacker using those credential to gain access to the application's data and services.,master,http://ivanti.polaris.synopsys.com/projects/e95bcef8-1a63-4b5b-a2e8-e2b0cee54d77/branches/15de2c52-d415-42e9-8b17-59a530bf8575/revisions/bb219060-6d92-403c-8c6c-88b7d598c058/issues/b9ef31ce6da307966397f07fecec528b048f41754fa4a6e02bf55c4517215396,b9ef31ce6da307966397f07fecec528b048f41754fa4a6e02bf55c4517215396,3ea4d65ecccea2bd15377091cb7684f1,2.0,opened,"CWE-260,CWE-798",IntegrationBusUnitTest/bin/Release/TestData/936aa3df-b1cf-4b6a-acf9-4ae6669cfbfd.json,,CONFIG.HARDCODED_CREDENTIALS_AUDIT,hardcoded_credentials:hardcoded_credentials_audit|c#,"3057 							""SerialNumber"": ""12345-678-1111111-54321"",
3058 							""MUILanguage"": ""English""
3059 						},
3060 						""Policy"":
3061 						{
3062 							""StrongPassword"": ""Yes"",
3063 							""ScreenSaverPassword"": ""No""
",The credential is hardcoded in the configuration file.,"Private credentials should be configured in a hardware security module. When other credentials are stored in configuration files, the files should not be checked into the code repository. When the application is deployed, the credentials should be baked in the image for deployment and only stored as environment variables. Remember that development and test credentials must also differ from production credentials.
",IntegrationServer
46,Hardcoded credentials in configuration file,The credentials value is stored in a configuration file..Having hardcoded credentials in configuration files accessible to potentially malicious users leads an attacker using those credential to gain access to the application's data and services.,master,http://ivanti.polaris.synopsys.com/projects/e95bcef8-1a63-4b5b-a2e8-e2b0cee54d77/branches/15de2c52-d415-42e9-8b17-59a530bf8575/revisions/bb219060-6d92-403c-8c6c-88b7d598c058/issues/bcaa61e41a1c6a82d78c12bf36dbf1f5a615cb080729b97e6aa06e3d1b9f14b9,bcaa61e41a1c6a82d78c12bf36dbf1f5a615cb080729b97e6aa06e3d1b9f14b9,3ec249a0b32c836913e1d76e7b3c05a3,2.0,opened,"CWE-260,CWE-798",tools/IntegrationRecordingTool/IntRecTool/Blobs_rr_EPM/ba58badd-196b-4de3-becc-3ef4f2e0d546.json,,CONFIG.HARDCODED_CREDENTIALS_AUDIT,hardcoded_credentials:hardcoded_credentials_audit|c#,"5218 	            ""MUILanguage"": ""Chinese (Simplified)"",
5219 	            ""BuildLab"": ""7601.win7sp1_ldr.160408-2045""
5220 	          },
5221 	          ""Policy"": {
5222 	            ""StrongPassword"": ""No"",
5223 	            ""ScreenSaverPassword"": ""Yes""
5224 	          },
",The credential is hardcoded in the configuration file.,"Private credentials should be configured in a hardware security module. When other credentials are stored in configuration files, the files should not be checked into the code repository. When the application is deployed, the credentials should be baked in the image for deployment and only stored as environment variables. Remember that development and test credentials must also differ from production credentials.
",IntegrationServer
47,Non-constant SQL,"An SQL statement is constructed by concatenating a non-constant string..Malicious or rogue values may alter the intent of the SQL query or command and cause incorrect behavior, leaked sensitive information, or a loss of data.",master,http://ivanti.polaris.synopsys.com/projects/e95bcef8-1a63-4b5b-a2e8-e2b0cee54d77/branches/15de2c52-d415-42e9-8b17-59a530bf8575/revisions/13a7ac9a-aa5f-4981-b23c-fd28ddfad0e5/issues/bcae52d06d9aa3998008b7a007a7bd064967d11f796b94bb6c083718384e09d3,bcae52d06d9aa3998008b7a007a7bd064967d11f796b94bb6c083718384e09d3,387253dbc360a39e391737e3f446742c,2.0,opened,"CWE-141,CWE-142,CWE-143,CWE-146,CWE-149,CWE-150,CWE-157,CWE-566,CWE-89",IntegrationDataAccess/IntegrationDataAccess.cs,,SQL_NOT_CONSTANT,sql_injection:audit_non_constant_concat|c#,"1342 	                    .Append(""JOIN FusionLink l "")
1343 	                    .Append(""ON t1.[Userdata2] = l.[SourceID] and t1.[WorkflowBlockId] = l.TargetID "")
1344 	                    .Append(""WHERE t1.[EscServiceId] = 5 "")
1345 	                    .Append(""AND i1.[Active] = 1 ) )"");
1347 	                SqlCommand deleteCmd = new SqlCommand(sql.ToString(), conn);
","Calling ""SqlCommand"". Passing the tainted value ""sql.ToString()"" to the SQL API may allow an attacker to inject SQL.","Calling ""ToString"". This call assigns ""sql"" to ""<return value>"". Now ""<return value>"" is tainted.
Calling ""ToString"". This call returns a reference to ""<return value>"".
Use one of the following methods:
* Use a query-preparation API to safely construct the SQL query containing user-supplied values.
* Only concatenate a user-supplied value into a query if it has been checked against a whitelist of safe string values, or if it must be a Boolean or numeric type.

",IntegrationServer
48,Explicit null dereferenced,Dereference of an explicit null value.A null pointer exception will occur.,master,http://ivanti.polaris.synopsys.com/projects/e95bcef8-1a63-4b5b-a2e8-e2b0cee54d77/branches/15de2c52-d415-42e9-8b17-59a530bf8575/revisions/4d324b91-7336-4b9f-b4d6-c29a48ceb332/issues/bceab8efb45eaf63283170a7b057b97dcf92b29241b1b267f500d06132d328d7,bceab8efb45eaf63283170a7b057b97dcf92b29241b1b267f500d06132d328d7,2466f8c9580c8df4704688503054d07f,7.5,opened,CWE-476,XMLGenerator/GenerateXML.cs,,FORWARD_NULL,null_pointer_dereference_exception:constant_null|c#,"367 	        }
368 	
369 	        private void WriteTaskAssignmentFields(XmlTextWriter writer, int number)
370 	        {
371 	            writer.WriteStartElement(""Field"");
372 	            writer.WriteAttributeString(""Name"", null, ""AssignmentID"");
373 	            writer.WriteValue(number.ToString());
374 	            writer.WriteEndElement();
375 	
376 	            writer.WriteStartElement(""Field"");
","Passing ""null"" to ""WriteAttributeString"", which dereferences it.",,IntegrationServer
49,Data race condition,"Thread shared data is accessed without holding an appropriate lock, possibly causing a race condition.The value of the shared data will be determined by the interleaving of thread execution.",master,http://ivanti.polaris.synopsys.com/projects/e95bcef8-1a63-4b5b-a2e8-e2b0cee54d77/branches/15de2c52-d415-42e9-8b17-59a530bf8575/revisions/4d324b91-7336-4b9f-b4d6-c29a48ceb332/issues/bdad675b27a2610486ce30762b3476345a7934aaf5c4c390413a4b200079912b,bdad675b27a2610486ce30762b3476345a7934aaf5c4c390413a4b200079912b,48d9f6a3179cda4047484f0006996baa,7.5,opened,"CWE-366,CWE-567",IntegrationDataAccess/IntegrationServiceTelemetry.cs,,GUARDED_BY_VIOLATION,race_condition:missing_lock|c#,"34 						if (_instance == null)
35 							_instance = GetInstance();
36 					}
37 					return _instance;
38 				}
39 			}
40 	
41 			private static IntegrationQueueTelemetry GetInstance()
","Accessing ""FRS.IntegrationServer.Telemetry.IntegrationQueueTelemetry._instance"" without holding lock ""FRS.IntegrationServer.Telemetry.IntegrationQueueTelemetry._syncRoot"". Elsewhere, ""FRS.IntegrationServer.Telemetry.IntegrationQueueTelemetry._instance"" is accessed with ""FRS.IntegrationServer.Telemetry.IntegrationQueueTelemetry._syncRoot"" held 2 out of 3 times.",,IntegrationServer
50,Non-constant SQL,"An SQL statement is constructed by concatenating a non-constant string..Malicious or rogue values may alter the intent of the SQL query or command and cause incorrect behavior, leaked sensitive information, or a loss of data.",master,http://ivanti.polaris.synopsys.com/projects/e95bcef8-1a63-4b5b-a2e8-e2b0cee54d77/branches/15de2c52-d415-42e9-8b17-59a530bf8575/revisions/13a7ac9a-aa5f-4981-b23c-fd28ddfad0e5/issues/be5efc195181462d53820e9e49946256dfab5c8618e043bd13d52cd169f2bf42,be5efc195181462d53820e9e49946256dfab5c8618e043bd13d52cd169f2bf42,595f4357e3a252468360c628d3007a6f,2.0,opened,"CWE-141,CWE-142,CWE-143,CWE-146,CWE-149,CWE-150,CWE-157,CWE-566,CWE-89",IntegrationDataAccess/IntegrationDataAccess.cs,,SQL_NOT_CONSTANT,sql_injection:audit_non_constant_concat|c#,"1276 	                   .Append(""AND [WorkflowInstanceId] = 'ScheduleEntry' "")
1277 	                   .Append(""AND [WorkflowBlockId] = @scheduleRecId"");
1278 	
1279 	                using (SqlTransaction trans = conn.BeginTransaction())
1280 	                {
1281 	                    SqlCommand cmd = new SqlCommand(sql.ToString(), conn);
1282 	                    cmd.Transaction = trans;
1283 	
1284 	                    cmd.Parameters.AddWithValue(""@SetOffInSeconds"", setOffInSeconds);
1285 	                    cmd.Parameters.AddWithValue(""@EscServiceId"", com.frontrange.saas.Workflow.Common.Enums.EscServiceIdEnum.IntegrationService);
","Calling ""SqlCommand"". Passing the tainted value ""sql.ToString()"" to the SQL API may allow an attacker to inject SQL.","Use one of the following methods:
* Use a query-preparation API to safely construct the SQL query containing user-supplied values.
* Only concatenate a user-supplied value into a query if it has been checked against a whitelist of safe string values, or if it must be a Boolean or numeric type.

Calling ""ToString"". This call assigns ""sql"" to ""<return value>"". Now ""<return value>"" is tainted.
Calling ""ToString"". This call returns a reference to ""<return value>"".
",IntegrationServer
51,Non-constant SQL,"An SQL statement is constructed by concatenating a non-constant string..Malicious or rogue values may alter the intent of the SQL query or command and cause incorrect behavior, leaked sensitive information, or a loss of data.",master,http://ivanti.polaris.synopsys.com/projects/e95bcef8-1a63-4b5b-a2e8-e2b0cee54d77/branches/15de2c52-d415-42e9-8b17-59a530bf8575/revisions/13a7ac9a-aa5f-4981-b23c-fd28ddfad0e5/issues/bee093945a481f4214861741874ecf05162c88ca67f655565fb162998b777652,bee093945a481f4214861741874ecf05162c88ca67f655565fb162998b777652,69f77efb822c5e34261aeadbabbefe4e,2.0,opened,"CWE-141,CWE-142,CWE-143,CWE-146,CWE-149,CWE-150,CWE-157,CWE-566,CWE-89",IntegrationDataAccess/IntegrationDataAccess.cs,,SQL_NOT_CONSTANT,sql_injection:audit_non_constant_concat|c#,"497 	                .Append(""AND (qq.[ManagedByMessageQueue] IS NULL OR qq.[ManagedByMessageQueue] <> 1) "")
498 	                .Append(""AND qr.RecId IS NULL"");
499 	
500 	            using (SqlConnection conn = (SqlConnection)this.GetConnection(DBAuth.ConnStringWithProvider(), DBAuth.TenantId))
501 	            {
502 	                using (SqlCommand cmd = new SqlCommand(sql.ToString(), conn))
503 	                {
","Calling ""SqlCommand"". Passing the tainted value ""sql.ToString()"" to the SQL API may allow an attacker to inject SQL.","Calling ""ToString"". This call assigns ""sql"" to ""<return value>"". Now ""<return value>"" is tainted.
Calling ""ToString"". This call returns a reference to ""<return value>"".
Use one of the following methods:
* Use a query-preparation API to safely construct the SQL query containing user-supplied values.
* Only concatenate a user-supplied value into a query if it has been checked against a whitelist of safe string values, or if it must be a Boolean or numeric type.

",IntegrationServer
52,Explicit null dereferenced,Dereference of an explicit null value.A null pointer exception will occur.,master,http://ivanti.polaris.synopsys.com/projects/e95bcef8-1a63-4b5b-a2e8-e2b0cee54d77/branches/15de2c52-d415-42e9-8b17-59a530bf8575/revisions/4d324b91-7336-4b9f-b4d6-c29a48ceb332/issues/c6c0a36e808a58067406a16f89430740bdb95993aee150b6a5514cdb7cf62082,c6c0a36e808a58067406a16f89430740bdb95993aee150b6a5514cdb7cf62082,6dab7d93015d5b006a09150a18a69b4d,7.5,opened,CWE-476,XMLGenerator/GenerateXML.cs,,FORWARD_NULL,null_pointer_dereference_exception:constant_null|c#,"203 	        }
204 	
205 	        private void WriteIncidentFields(XmlTextWriter writer, int number)
206 	        {
207 	            writer.WriteStartElement(""Field"");
208 	            writer.WriteAttributeString(""Name"", null, ""IncidentNumber"");
209 	            writer.WriteValue(number.ToString());
210 	            writer.WriteEndElement();
211 	
212 	            writer.WriteStartElement(""Field"");
","Passing ""null"" to ""WriteAttributeString"", which dereferences it.",,IntegrationServer
53,Non-constant SQL,"An SQL statement is constructed by concatenating a non-constant string..Malicious or rogue values may alter the intent of the SQL query or command and cause incorrect behavior, leaked sensitive information, or a loss of data.",master,http://ivanti.polaris.synopsys.com/projects/e95bcef8-1a63-4b5b-a2e8-e2b0cee54d77/branches/15de2c52-d415-42e9-8b17-59a530bf8575/revisions/13a7ac9a-aa5f-4981-b23c-fd28ddfad0e5/issues/c6e30a9f2cd8b7e3501ef84939289306303f2bfbf963cb58971ac571b3460ceb,c6e30a9f2cd8b7e3501ef84939289306303f2bfbf963cb58971ac571b3460ceb,a9f79928d224e905bd7a3d590750df95,2.0,opened,"CWE-141,CWE-142,CWE-143,CWE-146,CWE-149,CWE-150,CWE-157,CWE-566,CWE-89",IntegrationDataAccess/IntegrationDataAccess.cs,,SQL_NOT_CONSTANT,sql_injection:audit_non_constant_concat|c#,"1311 	                   .Append(""AND [UserData] = 'Frs_def_integration' "")
1312 	                   .Append(""AND [UserData2] = @integrationObjectRecId "")
1313 	                   .Append(""AND [WorkflowInstanceId] = 'ScheduleEntry' "")
1314 	                   .Append(""AND [WorkflowBlockId] = @scheduleRecId"");
1316 	                SqlCommand cmd = new SqlCommand(sql.ToString(), conn);
","Calling ""SqlCommand"". Passing the tainted value ""sql.ToString()"" to the SQL API may allow an attacker to inject SQL.","Calling ""ToString"". This call assigns ""sql"" to ""<return value>"". Now ""<return value>"" is tainted.
Calling ""ToString"". This call returns a reference to ""<return value>"".
Use one of the following methods:
* Use a query-preparation API to safely construct the SQL query containing user-supplied values.
* Only concatenate a user-supplied value into a query if it has been checked against a whitelist of safe string values, or if it must be a Boolean or numeric type.

",IntegrationServer
54,Hardcoded credentials in configuration file,The credentials value is stored in a configuration file..Having hardcoded credentials in configuration files accessible to potentially malicious users leads an attacker using those credential to gain access to the application's data and services.,master,http://ivanti.polaris.synopsys.com/projects/e95bcef8-1a63-4b5b-a2e8-e2b0cee54d77/branches/15de2c52-d415-42e9-8b17-59a530bf8575/revisions/6bfbc409-2c3f-4c7a-820a-ae63226652ce/issues/caf79a53a739ea3db91e849ea0509493b2345c7240309e8df6f602602f0b6d58,caf79a53a739ea3db91e849ea0509493b2345c7240309e8df6f602602f0b6d58,7955d4242d34ba2028cdba6157a1a612,2.0,opened,"CWE-260,CWE-798",TestProject/bin/Release/Microsoft.Azure.Services.AppAuthentication.xml,,CONFIG.HARDCODED_CREDENTIALS_AUDIT,hardcoded_credentials:hardcoded_credentials_audit|c#,"91 	            Gets an access token to access the given Azure resource. 
92 	            </summary>
93 	            <example>
94 	            <code>
95 	            var azureServiceTokenProvider = new AzureServiceTokenProvider();
96 	            string accessToken = await azureServiceTokenProvider.GetAccessTokenAsync(""https://management.azure.com/"").ConfigureAwait(false);
97 	            </code>
",The credential is hardcoded in the configuration file.,"Private credentials should be configured in a hardware security module. When other credentials are stored in configuration files, the files should not be checked into the code repository. When the application is deployed, the credentials should be baked in the image for deployment and only stored as environment variables. Remember that development and test credentials must also differ from production credentials.
",IntegrationServer
55,Non-constant SQL,"An SQL statement is constructed by concatenating a non-constant string..Malicious or rogue values may alter the intent of the SQL query or command and cause incorrect behavior, leaked sensitive information, or a loss of data.",master,http://ivanti.polaris.synopsys.com/projects/e95bcef8-1a63-4b5b-a2e8-e2b0cee54d77/branches/15de2c52-d415-42e9-8b17-59a530bf8575/revisions/13a7ac9a-aa5f-4981-b23c-fd28ddfad0e5/issues/dca4338a84342215f773511c09b23c05fd8370e11a774437bf239ce3cb34a76c,dca4338a84342215f773511c09b23c05fd8370e11a774437bf239ce3cb34a76c,a048d0c93bbf85dfb7b6ade39faeee3b,2.0,opened,"CWE-141,CWE-142,CWE-143,CWE-146,CWE-149,CWE-150,CWE-157,CWE-566,CWE-89",IntegrationDataAccess/IntegrationDataAccess.cs,,SQL_NOT_CONSTANT,sql_injection:audit_non_constant_concat|c#,"2015 	            {
2016 	                StringBuilder selectSQL = new StringBuilder();
2017 	                selectSQL.Append(""SELECT MappingDefinition FROM Frs_def_integration_mapping im INNER JOIN Frs_def_integration i ON im.IntegrationLink_RecID = i.RecId WHERE I.Active = 'true' and i.Published = 'true' and i.ConnectionLink_RecID = (select recid from Frs_def_integration_connection where DB = 'Device' and type = 'FRS.Integration.Connection.DeviceODataConnectionDef' and Active = 'true')"");
2018 	                using (SqlConnection conn = (SqlConnection)this.GetConnection(DBAuth.ConnStringWithProvider(), DBAuth.TenantId))
2019 	                {
2020 	                    SqlCommand cmd = new SqlCommand(selectSQL.ToString(), conn);
2021 	                    
","Calling ""SqlCommand"". Passing the tainted value ""selectSQL.ToString()"" to the SQL API may allow an attacker to inject SQL.","Calling ""ToString"". This call assigns ""selectSQL"" to ""<return value>"". Now ""<return value>"" is tainted.
Calling ""ToString"". This call returns a reference to ""<return value>"".
Use one of the following methods:
* Use a query-preparation API to safely construct the SQL query containing user-supplied values.
* Only concatenate a user-supplied value into a query if it has been checked against a whitelist of safe string values, or if it must be a Boolean or numeric type.

",IntegrationServer
56,Non-constant SQL,"An SQL statement is constructed by concatenating a non-constant string..Malicious or rogue values may alter the intent of the SQL query or command and cause incorrect behavior, leaked sensitive information, or a loss of data.",master,http://ivanti.polaris.synopsys.com/projects/e95bcef8-1a63-4b5b-a2e8-e2b0cee54d77/branches/15de2c52-d415-42e9-8b17-59a530bf8575/revisions/13a7ac9a-aa5f-4981-b23c-fd28ddfad0e5/issues/e3f3fbe0609bb73033896d10645585743648704c961031dd707acc5a82eb3978,e3f3fbe0609bb73033896d10645585743648704c961031dd707acc5a82eb3978,ef521856f3bed168a05ddfa90d073004,2.0,opened,"CWE-141,CWE-142,CWE-143,CWE-146,CWE-149,CWE-150,CWE-157,CWE-566,CWE-89",IntegrationDataAccess/IntegrationDataAccess.cs,,SQL_NOT_CONSTANT,sql_injection:audit_non_constant_concat|c#,"1829 	                        .Append(""                                          , RegistrationClientUri=@RegistrationClientUri"")
1830 	                        .Append("" END"");
1831 	
1832 	                    var client = new ConfigurationService(System.Configuration.ConfigurationManager.AppSettings[""CentralConfigURI""]);
1833 	                    
1834 	                    SqlCommand cmd = new SqlCommand(sql.ToString(), conn);
1835 	                    cmd.Parameters.AddWithValue(""@ClientID"", client.Encrypt(unoClientRegistrationDetails.ClientID, DBAuth.TenantId));
","Calling ""SqlCommand"". Passing the tainted value ""sql.ToString()"" to the SQL API may allow an attacker to inject SQL.","Calling ""ToString"". This call assigns ""sql"" to ""<return value>"". Now ""<return value>"" is tainted.
Calling ""ToString"". This call returns a reference to ""<return value>"".
Use one of the following methods:
* Use a query-preparation API to safely construct the SQL query containing user-supplied values.
* Only concatenate a user-supplied value into a query if it has been checked against a whitelist of safe string values, or if it must be a Boolean or numeric type.

",IntegrationServer
57,Explicit null dereferenced,Dereference of an explicit null value.A null pointer exception will occur.,master,http://ivanti.polaris.synopsys.com/projects/e95bcef8-1a63-4b5b-a2e8-e2b0cee54d77/branches/15de2c52-d415-42e9-8b17-59a530bf8575/revisions/4d324b91-7336-4b9f-b4d6-c29a48ceb332/issues/e504dcfccef5884b43974e9dff753fa64bb8837250461a465822b513924366b4,e504dcfccef5884b43974e9dff753fa64bb8837250461a465822b513924366b4,aa3a124cb75d73dc57f578ee254a4375,7.5,opened,CWE-476,XMLGenerator/GenerateXML.cs,,FORWARD_NULL,null_pointer_dereference_exception:constant_null|c#,"122 	        }
123 	
124 	        private void WriteRelatedBusinessObject(XmlTextWriter writer, int number, ChildBOInput child)
125 	        {
126 	            writer.WriteStartElement(""RelatedBusinessObject"");
127 	            writer.WriteAttributeString(""Relationship"", null, child.RelationShipName);
128 	            int childNUmber = 0;
129 	            WriteBusinessObject(writer, child.Name, number, child.ChildBOListInput, ref childNUmber, false);
130 	            writer.WriteEndElement(); // RelatedBusinessObject
131 	        }
","Passing ""null"" to ""WriteAttributeString"", which dereferences it.",,IntegrationServer
58,Non-constant SQL,"An SQL statement is constructed by concatenating a non-constant string..Malicious or rogue values may alter the intent of the SQL query or command and cause incorrect behavior, leaked sensitive information, or a loss of data.",master,http://ivanti.polaris.synopsys.com/projects/e95bcef8-1a63-4b5b-a2e8-e2b0cee54d77/branches/15de2c52-d415-42e9-8b17-59a530bf8575/revisions/d96e8b1f-4e16-4597-abaa-d6c5b554fc52/issues/f0166bf5e541f932c7136d90fb10a3c8bfdedcc3eda9082162e33c8168951601,f0166bf5e541f932c7136d90fb10a3c8bfdedcc3eda9082162e33c8168951601,135bec8dfef82e5903ab91dc45db5840,2.0,opened,"CWE-141,CWE-142,CWE-143,CWE-146,CWE-149,CWE-150,CWE-157,CWE-566,CWE-89",IntegrationDataAccess/IntegrationDataAccess.cs,,SQL_NOT_CONSTANT,sql_injection:audit_non_constant_concat|c#,"889 	                            if (integnHistoryColumnNames.Contains(""QuotaUtilized"") && integnHistoryColumnNames.Contains(""QuotaAvailable""))
890 	                            {    
891 	                                sqlText.Append("", QuotaUtilized = @QuotaUtilized, QuotaAvailable = @QuotaAvailable "");
892 	                            }
893 	                            sqlText.Append(""where QueueLink_RecID=@RecId and (QueueStatus=@Running or QueueStatus=@Aborting or QueueStatus=@AbortRequested)"");
894 	                            cmd.CommandText = sqlText.ToString();
895 	                            cmd.Parameters.AddWithValue(""@Completed"", ""Completed"");
","Calling ""CommandText.set"". Passing the tainted value ""sqlText.ToString()"" to the SQL API may allow an attacker to inject SQL. (The virtual call resolves to ""System.Data.SqlClient.SqlCommand.CommandText.set(System.String)"".)","Calling ""ToString"". This call assigns ""sqlText"" to ""<return value>"". Now ""<return value>"" is tainted.
Calling ""ToString"". This call returns a reference to ""<return value>"".
Use one of the following methods:
* Use a query-preparation API to safely construct the SQL query containing user-supplied values.
* Only concatenate a user-supplied value into a query if it has been checked against a whitelist of safe string values, or if it must be a Boolean or numeric type.

",IntegrationServer
59,Dereference null return value,"Return value of function which returns null is dereferenced without checking.If the function actually returns a null reference, a null reference exception will occur.",master,http://ivanti.polaris.synopsys.com/projects/e95bcef8-1a63-4b5b-a2e8-e2b0cee54d77/branches/15de2c52-d415-42e9-8b17-59a530bf8575/revisions/4d324b91-7336-4b9f-b4d6-c29a48ceb332/issues/f04ffe55e4ba375e729825df877e6dee4750bdaa529fe319a4daaba06daff4af,f04ffe55e4ba375e729825df877e6dee4750bdaa529fe319a4daaba06daff4af,172fef7a0d419ecec1e8b278f368fd9d,7.5,opened,CWE-476,tools/Message_Generator_Utility/Message_Generator_Utility/Program.cs,,NULL_RETURNS,null_pointer_dereference_exception:return_value|c#,"54 	                    if (deletefromPath)
55 	                    {
56 	                        deletefiles(softwareBlobPath);
57 	                        deletefiles(softwareMessagePath);
58 	                    }
59 	                    SWGenerator(UnoTenantId, Tenant_id, NoOfMessage, softwareMessagePath, softwareBlobPath);
60 	                }
61 	                if (TypeOFMessage == ""All"")
","Throws an exception when ""softwareMessagePath"", a pointer that might be ""null"", is ""null"" when calling ""deletefiles"".",,IntegrationServer
60,Non-constant SQL,"An SQL statement is constructed by concatenating a non-constant string..Malicious or rogue values may alter the intent of the SQL query or command and cause incorrect behavior, leaked sensitive information, or a loss of data.",master,http://ivanti.polaris.synopsys.com/projects/e95bcef8-1a63-4b5b-a2e8-e2b0cee54d77/branches/15de2c52-d415-42e9-8b17-59a530bf8575/revisions/13a7ac9a-aa5f-4981-b23c-fd28ddfad0e5/issues/f38aff10fd81bebbb5e3b5949fd217c68f38a6dbe855e7af9233a1cd103c2103,f38aff10fd81bebbb5e3b5949fd217c68f38a6dbe855e7af9233a1cd103c2103,2251d4b875590a448bdf598c6ab36448,2.0,opened,"CWE-141,CWE-142,CWE-143,CWE-146,CWE-149,CWE-150,CWE-157,CWE-566,CWE-89",IntegrationDataAccess/IntegrationDataAccess.cs,,SQL_NOT_CONSTANT,sql_injection:audit_non_constant_concat|c#,"196 	            StringBuilder selectSQL = new StringBuilder();
197 	            selectSQL.Append(""SELECT i.Name, q.Name FROM Frs_def_integration i left join Frs_def_quick_actions q on i.ConnectionLink_RecID = Replace(q.Id, '-', '') WHERE i.IsExport = 1 and i.RecId = @Id"");
198 	
199 	            using (SqlConnection conn = (SqlConnection)this.GetConnection(DBAuth.ConnStringWithProvider(), DBAuth.TenantId))
200 	            {
201 	                SqlCommand cmd = new SqlCommand(selectSQL.ToString(), conn);
202 	                cmd.Parameters.AddWithValue(""@Id"", integrationId);
","Calling ""SqlCommand"". Passing the tainted value ""selectSQL.ToString()"" to the SQL API may allow an attacker to inject SQL.","Calling ""ToString"". This call assigns ""selectSQL"" to ""<return value>"". Now ""<return value>"" is tainted.
Calling ""ToString"". This call returns a reference to ""<return value>"".
Use one of the following methods:
* Use a query-preparation API to safely construct the SQL query containing user-supplied values.
* Only concatenate a user-supplied value into a query if it has been checked against a whitelist of safe string values, or if it must be a Boolean or numeric type.

",IntegrationServer
61,Non-constant SQL,"An SQL statement is constructed by concatenating a non-constant string..Malicious or rogue values may alter the intent of the SQL query or command and cause incorrect behavior, leaked sensitive information, or a loss of data.",master,http://ivanti.polaris.synopsys.com/projects/e95bcef8-1a63-4b5b-a2e8-e2b0cee54d77/branches/15de2c52-d415-42e9-8b17-59a530bf8575/revisions/13a7ac9a-aa5f-4981-b23c-fd28ddfad0e5/issues/f8ff715f5135a221fcb89e0ab4d630eb6c01792088cdf536402903357f03e19e,f8ff715f5135a221fcb89e0ab4d630eb6c01792088cdf536402903357f03e19e,9a87e577f47465c5f44754c2af774b40,2.0,opened,"CWE-141,CWE-142,CWE-143,CWE-146,CWE-149,CWE-150,CWE-157,CWE-566,CWE-89",IntegrationDataAccess/IntegrationDataAccess.cs,,SQL_NOT_CONSTANT,sql_injection:audit_non_constant_concat|c#,"1913 	                StringBuilder selectSQL = new StringBuilder();
1914 	                selectSQL.Append(""SELECT Enabled FROM ivnt_Ivanti_Spend_Intelligence_Configuration WHERE Type=@type"");
1915 	
1916 	                using (SqlConnection conn = (SqlConnection)this.GetConnection(DBAuth.ConnStringWithProvider(), DBAuth.TenantId))
1917 	                {
1918 	                    SqlCommand cmd = new SqlCommand(selectSQL.ToString(), conn);
1919 	                    cmd.Parameters.AddWithValue(""@type"", type);
","Calling ""SqlCommand"". Passing the tainted value ""selectSQL.ToString()"" to the SQL API may allow an attacker to inject SQL.","Calling ""ToString"". This call assigns ""selectSQL"" to ""<return value>"". Now ""<return value>"" is tainted.
Calling ""ToString"". This call returns a reference to ""<return value>"".
Use one of the following methods:
* Use a query-preparation API to safely construct the SQL query containing user-supplied values.
* Only concatenate a user-supplied value into a query if it has been checked against a whitelist of safe string values, or if it must be a Boolean or numeric type.

",IntegrationServer
62,'Constant' variable guards dead code,"Variable assigned once to a constant guards dead code..A variable being assigned only once may be intentionally guarding disabled code, or it may represent incomplete logic where a missing assignment would make the variable not be constant.",master,http://ivanti.polaris.synopsys.com/projects/e95bcef8-1a63-4b5b-a2e8-e2b0cee54d77/branches/15de2c52-d415-42e9-8b17-59a530bf8575/revisions/4d324b91-7336-4b9f-b4d6-c29a48ceb332/issues/fc37e793ce4f7dad13fa110c2d53c464122542f94f880330650baf3cca14f81a,fc37e793ce4f7dad13fa110c2d53c464122542f94f880330650baf3cca14f81a,bcaa4bd9b4925f7d1dcc5e59b95f4246,5.5,opened,"CWE-1164,CWE-561",DynamicWebServiceTest/Form1.cs,,DEADCODE,deadcode:effectively_constant|c#,"40 	                if (hasBasicAuthentication)
41 	                {
42 	                    string userId = ""testUser"";
43 	                    string password = ""test123"";
","Execution cannot reach this statement: ""userId = ""testUser"";"".","Local variable ""hasBasicAuthentication"" is assigned only once, to a constant value, making it effectively constant throughout its scope. If this is not the intent, examine the logic to see if there is a missing assignment that would make ""hasBasicAuthentication"" not remain constant. Otherwise, declaring ""hasBasicAuthentication"" as ""const"" will suppress this defect.
",IntegrationServer
